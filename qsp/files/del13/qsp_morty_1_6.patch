diff --git a/meta-simics-qsp/conf/layer.conf b/meta-simics-qsp/conf/layer.conf
new file mode 100644
index 0000000..f8c57b7
--- /dev/null
+++ b/meta-simics-qsp/conf/layer.conf
@@ -0,0 +1,8 @@
+# We have a conf and classes directory, add to BBPATH
+BBPATH .= ":${LAYERDIR}"
+# We have recipes-* directories, add to BBFILES
+BBFILES += "${LAYERDIR}/recipes-*/*/*.bb \
+	${LAYERDIR}/recipes-*/*/*.bbappend"
+BBFILE_COLLECTIONS += "simics-qsp"
+BBFILE_PATTERN_simics-qsp = "^${LAYERDIR}/"
+BBFILE_PRIORITY_simics-qsp = "6"
diff --git a/meta-simics-qsp/recipes-core/base-files/base-files/fstab b/meta-simics-qsp/recipes-core/base-files/base-files/fstab
new file mode 100644
index 0000000..951651d
--- /dev/null
+++ b/meta-simics-qsp/recipes-core/base-files/base-files/fstab
@@ -0,0 +1,18 @@
+# stock fstab - you probably want to override this with a machine specific one
+
+/dev/root            /                    auto       defaults              1  1
+proc                 /proc                proc       defaults              0  0
+devpts               /dev/pts             devpts     mode=0620,gid=5       0  0
+usbdevfs             /proc/bus/usb        usbdevfs   noauto                0  0
+tmpfs                /run                 tmpfs      mode=0755,nodev,nosuid,strictatime 0  0
+tmpfs                /var/volatile        tmpfs      defaults              0  0
+
+# uncomment this if your device has a SD/MMC/Transflash slot
+#/dev/mmcblk0p1       /media/card          auto       defaults,sync,noauto  0  0
+
+# SimicsFS
+simicsfs           /host                simicsfs       defaults,noauto       0  0
+
+# Disk2
+/dev/sdb1            /disk2               auto       defaults              0  0
+
diff --git a/meta-simics-qsp/recipes-core/base-files/base-files_3.0.14.bbappend b/meta-simics-qsp/recipes-core/base-files/base-files_3.0.14.bbappend
new file mode 100644
index 0000000..2b9351d
--- /dev/null
+++ b/meta-simics-qsp/recipes-core/base-files/base-files_3.0.14.bbappend
@@ -0,0 +1 @@
+FILESEXTRAPATHS_append := "${THISDIR}/${PN}:"
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/CHANGES b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/CHANGES
new file mode 100644
index 0000000..5b2a883
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/CHANGES
@@ -0,0 +1,111 @@
+CHANGES:
+========
+
+1.21 * Added support for Linux kernel version 4.9.
+     * inode_change_ok replaced by setattr_prepare.
+
+1.20 * Added support for kernel versions up to 4.8.
+     * PAGE_CACHE_* macros removed, replace with PAGE_*.
+     * follow_link removed from inode_operations, replace with get_link.
+     * readlink_copy removed, replace with generic_readlink.
+     * New debug level argument to the kernel module.
+
+1.19 * Added support for kernel versions up to 4.3.
+
+1.18 * Added support for 3.16 kernels.
+     * Updated the README with more information about building
+     * Added information about finding a physical address to the README
+     * Provide the README also in HTML and PDF formats
+
+1.17 * Remove support for kernels < 2.6.12, since they are untested.
+     * Update to linux coding style.
+     * Fixed compilation for kernel 3.14 when CONFIG_USER_NS is set.
+     * Fixed a compilation issue for kernel 3.15, where
+       - vfs_readlink is replaced by readlink_copy
+
+1.16 * Fixed compilation for kernels >= 3.10. Bug 20435.
+     * Fixed compilation for kernel 2.6.28. Bug 17663.
+     * Avoid buffer overflow in hostfs_lookup_inode. Bug 19698.
+
+1.15 * Fixed compilation on kernels >= 3.4. Bug 18651.
+
+1.14 * Fixed compilation on kernels >= 3.2. Bug 18089.
+
+1.13 * Made CONFIG_SIMICSFS_ADDRESS depend on CONFIG_SIMICSFS. Bug 16696.
+     * Fixed compilation warnings on linux kernels >= 2.6.34
+     * Fix compilation on kernels >= 2.6.39
+       - .get_fs is replaced by .mount
+       - SPIN_LOCK_UNLOCKED replaced by run-time initialization
+     * Allocate large buffers on the heap instead of the stack to reduce the
+       risk of stack overflow. Found by the -Wframe-larger-than=1024 option.
+       Bug 16856.
+     * Known failure to compile on kernel == 2.6.28, missing function
+       ‘grab_cache_page_write_begin’, bug 17663.
+
+1.12 * Added SimicsFS Kconfig file. fs/Kconfig should be updated to source it.
+       See README_2.6 for more information. Bug 14266.
+     * Added support for M68K.
+     * Removed support for setting the hostfs physical address using
+       "simicsfs=0xf00ba0". Use "simicsfs.phys_addr=0xf00ba0" instead.
+     * Made the default hostfs physical address configurable. This is done
+       by setting the kernel config option CONFIG_SIMICSFS_ADDRESS.
+     * Fix compilation on linux kernels >= 2.6.36
+       - removed .truncate
+       - .setattr updated to handle ATTR_SIZE
+       - .setattr updated to not call inode_setattr
+
+1.11 * Support > 32-bit hfs addresses on 32-bit targets
+     * Fixed typo in hostfs.h which can to lead to compiler errors,
+       depending on target
+
+1.10 * Replace ClearPageLocked with unlock_page on kernels 2.6.27 and newer.
+     * Replace address_space_operations functions prepare_write and commit_write
+       with write_begin and write_end on kernels 2.6.28 and newer.
+     * Add MIPS support for 2.6 compilation (tested with 2.6.23).
+
+1.9 * Revalidate inode before read/write/getattr accesses; this fixes issues
+      with changes made from the host system not being seen on the target.
+      For performance reasons, mount /host with noatime.
+
+    * Fix compilation on linux kernels >= 2.6.19:
+        - aio_read/aio_write prototype changed
+
+    * Fix compilation on linux kernels >= 2.6.25:
+        - iget removed
+        - .inode_read removed
+
+1.8 * Use struct path instead of accessing f_dentry directly
+      on linux kernels >= 2.6.20
+      Fixed kernel crash issue introduced in 1.7.
+
+1.7 * Fix compilation on linux kernels >= 2.6.18:
+        - get_sb* prototypes changed
+        - statfs prototypes changed
+
+    * Fix compilation on linux kernels >= 2.6.19:
+        - error: linux/config.h: No such file or directory
+        - error: 'struct inode' has no member named 'i_blksize'
+        - warning: implicit declaration of function 'generic_file_read/write'
+
+1.6 * Support passing of hostfs device address via kernel command line or
+      module parameter on 2.6.x kernels.
+
+    * Fixed a bug in read that caused kernels with highmem support to crash.
+
+1.5 * Support for new simicsfs interface on UltraSPARC machines. Requires
+      Simics build 1336 or newer.
+
+    * Support for ARM targets.
+
+1.4 * Fix compilation on kernels >= 2.6.13 (follow_link prototype changed).
+
+1.3 * Fix crash when unmounting on 2.6.x kernels.
+
+1.2 * Corrected hostfs device address for SPARC (SunFire) target, that works
+      with 2.6 kernel.
+
+    * Simplified build of kernel module for a Linux 2.6 kernel.
+
+1.1 * Added support for Linux 2.6 kernels.
+
+1.0 * Base version
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/Kconfig b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/Kconfig
new file mode 100644
index 0000000..801ba83
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/Kconfig
@@ -0,0 +1,18 @@
+config SIMICSFS
+       tristate "Simics hostfs"
+       help
+          This filesystem allows Simics to acces the host filesystem.
+
+          To compile this file system support as a module, choose M here. The
+          module will be called simicsfs.
+
+          If unsure, say N.
+
+config SIMICSFS_ADDRESS
+       string "SimicsFS physical address"
+       depends on SIMICSFS
+       help
+          The default address at which the Simics hostfs module is mapped.
+          Can be overriden by setting the phys_addr module parameter.
+
+          If you are not sure, leave it blank.
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/Makefile b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/Makefile
new file mode 100644
index 0000000..b6b2134
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/Makefile
@@ -0,0 +1,33 @@
+#
+# Makefile for Simics hostfs
+
+ifeq (,$(CONFIG_SIMICSFS))
+CONFIG_SIMICSFS=m
+endif
+
+ifneq ($(KERNELRELEASE),)
+
+# building with Kbuild
+obj-m := simicsfs.o
+simicsfs-y := hostfs_inode.o hostfs_super.o hostfs_dir.o hostfs_file.o \
+	hostfs_host.o
+
+else
+
+# building normally
+KERNELDIR ?= /lib/modules/`uname -r`/build
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+
+modules_install:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
+
+tests:
+	 $(MAKE) -C $@ $(BUILD_RULE)
+
+clean:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) clean
+
+.PHONY: clean tests
+
+endif
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/README b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/README
new file mode 100644
index 0000000..7cf478e
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/README
@@ -0,0 +1,149 @@
+SimicsFS Read Me
+
+   Table of Contents
+     * 1   Introduction
+     * 2   Compiling SimicsFS for a running kernel
+     * 3   Adding SimicsFS to a kernel source tree
+     * 4   How to find and set a physical address for the driver
+     * 5   How to override the physical address of the driver
+
+1   Introduction
+
+   SimicsFS is a Linux kernel module used to mount the host filesystem
+   from within the simulated target system. It provides both read and
+   write access to files located on the host filesystem.
+
+   SimicsFS is provided as source code and the user must compile it
+   against the Linux kernel source code for the target system.
+   Pre-compiled modules are available in most images distributed in Simics
+   packages.
+
+1.1   Limitations
+
+     * Linux kernel 2.6.12 and later only
+     * The code is not production quality
+     * The module receives limited testing
+
+2   Compiling SimicsFS for a running kernel
+
+    1. Unpack the simicsfs archive (where x.y is the version number).
+$ tar xzf simicsfs-x.y.tar.gz
+
+    2. Install the kernel source and development packages.
+       See the distribution documentation for more information about how
+       to find and install packages.
+    3. Build the kernel source code.
+       See the distribution documentation for more information on how to
+       build its kernel; typically it is enough to run make in the source
+       code root directory.
+    4. Build the kernel module.
+       Change to the simicsfs directory, and then compile:
+$ make -C /lib/modules/`uname -r`/build M=`pwd`
+
+    5. Install the kernel module.
+       The resulting simicsfs.ko module file must be inserted into the
+       running kernel. Optionally it may be configured, which is described
+       in section How to override the physical address of the driver:
+$ insmod simicsfs.ko
+
+       If a simicsfs module is already inserted in the kernel, it must
+       first be removed by using rmmod.
+
+   The Linux kernel source code provides more information about building
+   external modules in Documentation/kbuild/modules.txt.
+
+3   Adding SimicsFS to a kernel source tree
+
+    1. Unpack the simicsfs archive in the Linux fs directory.
+       You must update the file and path names with the current version
+       numbers:
+$ cd /path/to/linux-x.y.z/fs/
+$ tar xzf simicsfs-x.y.tar.gz
+
+    2. Edit fs/Makefile and fs/Kconfig.
+       Append the following line to the end of fs/Makefile:
+obj-$(CONFIG_SIMICSFS)             += simicsfs/
+
+       Add the following line to the end of the section "Miscellaneous
+       filesystems" in the fs/Kconfig file:
+source "fs/simicsfs/Kconfig"
+
+    3. Configure the Linux kernel and select simicsfs as a module.
+$ make menuconfig
+File systems  --->
+Miscellaneous filesystems  --->
+<M>     Simics hostfs
+
+       Optionally you may set a default physical address, which is
+       described in the section How to find and set a physical address for
+       the driver.
+    4. Compile the kernel and its modules.
+       Check the distribution documentation for instructions on how to
+       build the Linux kernel; typically it is enough to run make in the
+       source code root directory:
+$ make
+
+       Or build only the simicsfs module:
+$ make SUBDIRS=fs/simicsfs modules
+
+       The resulting module file is located at fs/simicsfs/simicsfs.ko.
+       See the README file in the Linux source code for more information
+       on how to build the kernel.
+    5. Install the kernel module.
+       The module can be either manually inserted into the target system
+       at run-time or automatically loaded by the kernel.
+       Check the distribution documentation for how to add a kernel module
+       to the target file system. Typically it involves placing the module
+       file under /lib/modules/`uname -r`/extra/fs/ and running depmod.
+       If necessary, see the section How to override the physical address
+       of the driver.
+       To manually load the kernel module at run-time:
+$ insmod simicsfs.ko
+
+       See man insmod for more information.
+
+4   How to find and set a physical address for the driver
+
+    1. Find a 4 kiB (0x1000) empty region in I/O memory. This command is
+       executed on the running target system: .. code:: bash
+
+     $ cat /proc/iomem
+       Note that the output is a static snapshot and may not show dynamic
+       usage of I/O memory.
+    2. Check the kernel configuration.
+$ grep CONFIG_SIMICSFS_ADDRESS .config
+CONFIG_SIMICSFS_ADDRESS=""
+
+       The string will not appear if the driver has not been selected and
+       it will be empty unless an address has been explicitly set.
+    3. Edit the configuration as necessary.
+$ make menuconfig
+File systems  --->
+Miscellaneous filesystems  --->
+<M>     Simics hostfs
+()      SimicsFS physical address
+
+       Once the Simics hostfs module has been selected, an option appears
+       where a default physical address can be entered. A built-in default
+       value is used unless the user specifies a new default address.
+       Later, you may want to override the address, see section How to
+       override the physical address of the driver.
+       Remember to save any changes before exiting.
+
+5   How to override the physical address of the driver
+
+     * If the driver was compiled-in (<*> in menuconfig)
+       Append this argument to the kernel command-line:
+simicsfs.phys_addr=0xff00ff00
+
+     * If the driver was compiled as a module (<M> in menuconfig)
+       Give an argument when loading the module:
+$ insmod simicsfs.ko phys_addr=0xff00ff00
+
+       Or by using modprobe, which requires depmod generated files to be
+       present on the target system:
+$ modprobe simicsfs phys_addr=0xff00ff00
+
+   Alternatively you can add it as an option in /etc/modules.conf,
+   /etc/modprobe.conf or similar, depending on what is provided by your
+   target system. Check the distribution documentation.
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/README.html b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/README.html
new file mode 100644
index 0000000..987a4ad
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/README.html
@@ -0,0 +1,534 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
+<title>SimicsFS Read Me</title>
+<style type="text/css">
+
+/*
+:Author: David Goodger (goodger@python.org)
+:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
+:Copyright: This stylesheet has been placed in the public domain.
+
+Default cascading style sheet for the HTML output of Docutils.
+
+See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
+customize this style sheet.
+*/
+
+/* used to remove borders from tables and images */
+.borderless, table.borderless td, table.borderless th {
+  border: 0 }
+
+table.borderless td, table.borderless th {
+  /* Override padding for "table.docutils td" with "! important".
+     The right padding separates the table cells. */
+  padding: 0 0.5em 0 0 ! important }
+
+.first {
+  /* Override more specific margin styles with "! important". */
+  margin-top: 0 ! important }
+
+.last, .with-subtitle {
+  margin-bottom: 0 ! important }
+
+.hidden {
+  display: none }
+
+a.toc-backref {
+  text-decoration: none ;
+  color: black }
+
+blockquote.epigraph {
+  margin: 2em 5em ; }
+
+dl.docutils dd {
+  margin-bottom: 0.5em }
+
+object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
+  overflow: hidden;
+}
+
+/* Uncomment (and remove this text!) to get bold-faced definition list terms
+dl.docutils dt {
+  font-weight: bold }
+*/
+
+div.abstract {
+  margin: 2em 5em }
+
+div.abstract p.topic-title {
+  font-weight: bold ;
+  text-align: center }
+
+div.admonition, div.attention, div.caution, div.danger, div.error,
+div.hint, div.important, div.note, div.tip, div.warning {
+  margin: 2em ;
+  border: medium outset ;
+  padding: 1em }
+
+div.admonition p.admonition-title, div.hint p.admonition-title,
+div.important p.admonition-title, div.note p.admonition-title,
+div.tip p.admonition-title {
+  font-weight: bold ;
+  font-family: sans-serif }
+
+div.attention p.admonition-title, div.caution p.admonition-title,
+div.danger p.admonition-title, div.error p.admonition-title,
+div.warning p.admonition-title, .code .error {
+  color: red ;
+  font-weight: bold ;
+  font-family: sans-serif }
+
+/* Uncomment (and remove this text!) to get reduced vertical space in
+   compound paragraphs.
+div.compound .compound-first, div.compound .compound-middle {
+  margin-bottom: 0.5em }
+
+div.compound .compound-last, div.compound .compound-middle {
+  margin-top: 0.5em }
+*/
+
+div.dedication {
+  margin: 2em 5em ;
+  text-align: center ;
+  font-style: italic }
+
+div.dedication p.topic-title {
+  font-weight: bold ;
+  font-style: normal }
+
+div.figure {
+  margin-left: 2em ;
+  margin-right: 2em }
+
+div.footer, div.header {
+  clear: both;
+  font-size: smaller }
+
+div.line-block {
+  display: block ;
+  margin-top: 1em ;
+  margin-bottom: 1em }
+
+div.line-block div.line-block {
+  margin-top: 0 ;
+  margin-bottom: 0 ;
+  margin-left: 1.5em }
+
+div.sidebar {
+  margin: 0 0 0.5em 1em ;
+  border: medium outset ;
+  padding: 1em ;
+  background-color: #ffffee ;
+  width: 40% ;
+  float: right ;
+  clear: right }
+
+div.sidebar p.rubric {
+  font-family: sans-serif ;
+  font-size: medium }
+
+div.system-messages {
+  margin: 5em }
+
+div.system-messages h1 {
+  color: red }
+
+div.system-message {
+  border: medium outset ;
+  padding: 1em }
+
+div.system-message p.system-message-title {
+  color: red ;
+  font-weight: bold }
+
+div.topic {
+  margin: 2em }
+
+h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
+h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
+  margin-top: 0.4em }
+
+h1.title {
+  text-align: center }
+
+h2.subtitle {
+  text-align: center }
+
+hr.docutils {
+  width: 75% }
+
+img.align-left, .figure.align-left, object.align-left {
+  clear: left ;
+  float: left ;
+  margin-right: 1em }
+
+img.align-right, .figure.align-right, object.align-right {
+  clear: right ;
+  float: right ;
+  margin-left: 1em }
+
+img.align-center, .figure.align-center, object.align-center {
+  display: block;
+  margin-left: auto;
+  margin-right: auto;
+}
+
+.align-left {
+  text-align: left }
+
+.align-center {
+  clear: both ;
+  text-align: center }
+
+.align-right {
+  text-align: right }
+
+/* reset inner alignment in figures */
+div.align-right {
+  text-align: inherit }
+
+/* div.align-center * { */
+/*   text-align: left } */
+
+ol.simple, ul.simple {
+  margin-bottom: 1em }
+
+ol.arabic {
+  list-style: decimal }
+
+ol.loweralpha {
+  list-style: lower-alpha }
+
+ol.upperalpha {
+  list-style: upper-alpha }
+
+ol.lowerroman {
+  list-style: lower-roman }
+
+ol.upperroman {
+  list-style: upper-roman }
+
+p.attribution {
+  text-align: right ;
+  margin-left: 50% }
+
+p.caption {
+  font-style: italic }
+
+p.credits {
+  font-style: italic ;
+  font-size: smaller }
+
+p.label {
+  white-space: nowrap }
+
+p.rubric {
+  font-weight: bold ;
+  font-size: larger ;
+  color: maroon ;
+  text-align: center }
+
+p.sidebar-title {
+  font-family: sans-serif ;
+  font-weight: bold ;
+  font-size: larger }
+
+p.sidebar-subtitle {
+  font-family: sans-serif ;
+  font-weight: bold }
+
+p.topic-title {
+  font-weight: bold }
+
+pre.address {
+  margin-bottom: 0 ;
+  margin-top: 0 ;
+  font: inherit }
+
+pre.literal-block, pre.doctest-block, pre.math, pre.code {
+  margin-left: 2em ;
+  margin-right: 2em }
+
+pre.code .ln { color: grey; } /* line numbers */
+pre.code, code { background-color: #eeeeee }
+pre.code .comment, code .comment { color: #5C6576 }
+pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
+pre.code .literal.string, code .literal.string { color: #0C5404 }
+pre.code .name.builtin, code .name.builtin { color: #352B84 }
+pre.code .deleted, code .deleted { background-color: #DEB0A1}
+pre.code .inserted, code .inserted { background-color: #A3D289}
+
+span.classifier {
+  font-family: sans-serif ;
+  font-style: oblique }
+
+span.classifier-delimiter {
+  font-family: sans-serif ;
+  font-weight: bold }
+
+span.interpreted {
+  font-family: sans-serif }
+
+span.option {
+  white-space: nowrap }
+
+span.pre {
+  white-space: pre }
+
+span.problematic {
+  color: red }
+
+span.section-subtitle {
+  /* font-size relative to parent (h1..h6 element) */
+  font-size: 80% }
+
+table.citation {
+  border-left: solid 1px gray;
+  margin-left: 1px }
+
+table.docinfo {
+  margin: 2em 4em }
+
+table.docutils {
+  margin-top: 0.5em ;
+  margin-bottom: 0.5em }
+
+table.footnote {
+  border-left: solid 1px black;
+  margin-left: 1px }
+
+table.docutils td, table.docutils th,
+table.docinfo td, table.docinfo th {
+  padding-left: 0.5em ;
+  padding-right: 0.5em ;
+  vertical-align: top }
+
+table.docutils th.field-name, table.docinfo th.docinfo-name {
+  font-weight: bold ;
+  text-align: left ;
+  white-space: nowrap ;
+  padding-left: 0 }
+
+/* "booktabs" style (no vertical lines) */
+table.docutils.booktabs {
+  border: 0px;
+  border-top: 2px solid;
+  border-bottom: 2px solid;
+  border-collapse: collapse;
+}
+table.docutils.booktabs * {
+  border: 0px;
+}
+table.docutils.booktabs th {
+  border-bottom: thin solid;
+  text-align: left;
+}
+
+h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
+h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
+  font-size: 100% }
+
+ul.auto-toc {
+  list-style-type: none }
+
+</style>
+</head>
+<body>
+<div class="document" id="simicsfs-read-me">
+<h1 class="title">SimicsFS Read Me</h1>
+
+<div class="contents topic" id="table-of-contents">
+<p class="topic-title first">Table of Contents</p>
+<ul class="auto-toc simple">
+<li><a class="reference internal" href="#introduction" id="id1">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
+<li><a class="reference internal" href="#compiling-simicsfs-for-a-running-kernel" id="id2">2&nbsp;&nbsp;&nbsp;Compiling SimicsFS for a running kernel</a></li>
+<li><a class="reference internal" href="#adding-simicsfs-to-a-kernel-source-tree" id="id3">3&nbsp;&nbsp;&nbsp;Adding SimicsFS to a kernel source tree</a></li>
+<li><a class="reference internal" href="#how-to-find-and-set-a-physical-address-for-the-driver" id="id4">4&nbsp;&nbsp;&nbsp;How to find and set a physical address for the driver</a></li>
+<li><a class="reference internal" href="#how-to-override-the-physical-address-of-the-driver" id="id5">5&nbsp;&nbsp;&nbsp;How to override the physical address of the driver</a></li>
+</ul>
+</div>
+<div class="section" id="introduction">
+<h1><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
+<p>SimicsFS is a Linux kernel module used to mount the host filesystem from within
+the simulated target system. It provides both read and write access to files
+located on the host filesystem.</p>
+<p>SimicsFS is provided as source code and the user must compile it against the
+Linux kernel source code for the target system. Pre-compiled modules are
+available in most images distributed in Simics packages.</p>
+<div class="section" id="limitations">
+<h2>1.1&nbsp;&nbsp;&nbsp;Limitations</h2>
+<ul class="simple">
+<li>Linux kernel 2.6.12 and later only</li>
+<li>The code is not production quality</li>
+<li>The module receives limited testing</li>
+</ul>
+</div>
+</div>
+<div class="section" id="compiling-simicsfs-for-a-running-kernel">
+<h1><a class="toc-backref" href="#id2">2&nbsp;&nbsp;&nbsp;Compiling SimicsFS for a running kernel</a></h1>
+<ol class="arabic">
+<li><p class="first">Unpack the simicsfs archive (where x.y is the version number).</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>tar xzf simicsfs-x.y.tar.gz
+</pre>
+</li>
+<li><p class="first">Install the kernel source and development packages.</p>
+<p>See the distribution documentation for more information about how to find
+and install packages.</p>
+</li>
+<li><p class="first">Build the kernel source code.</p>
+<p>See the distribution documentation for more information on how to build its
+kernel; typically it is enough to run <tt class="docutils literal">make</tt> in the source code root
+directory.</p>
+</li>
+<li><p class="first">Build the kernel module.</p>
+<p>Change to the simicsfs directory, and then compile:</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>make -C /lib/modules/<span class="literal string backtick">`</span>uname -r<span class="literal string backtick">`</span>/build <span class="name variable">M</span><span class="operator">=</span><span class="literal string backtick">`</span><span class="name builtin">pwd</span><span class="literal string backtick">`</span>
+</pre>
+</li>
+<li><p class="first">Install the kernel module.</p>
+<p>The resulting <tt class="docutils literal">simicsfs.ko</tt> module file must be inserted into the running
+kernel. Optionally it may be configured, which is described in section <a class="reference internal" href="#how-to-override-the-physical-address-of-the-driver">How
+to override the physical address of the driver</a>:</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>insmod simicsfs.ko
+</pre>
+<p>If a simicsfs module is already inserted in the kernel, it must first be
+removed by using <tt class="docutils literal">rmmod</tt>.</p>
+</li>
+</ol>
+<p>The Linux kernel source code provides more information about building external
+modules in <tt class="docutils literal">Documentation/kbuild/modules.txt</tt>.</p>
+</div>
+<div class="section" id="adding-simicsfs-to-a-kernel-source-tree">
+<h1><a class="toc-backref" href="#id3">3&nbsp;&nbsp;&nbsp;Adding SimicsFS to a kernel source tree</a></h1>
+<ol class="arabic">
+<li><p class="first">Unpack the simicsfs archive in the Linux <tt class="docutils literal">fs</tt> directory.</p>
+<p>You must update the file and path names with the current version numbers:</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span><span class="name builtin">cd</span> /path/to/linux-x.y.z/fs/
+<span class="name variable">$ </span>tar xzf simicsfs-x.y.tar.gz
+</pre>
+</li>
+<li><p class="first">Edit <tt class="docutils literal">fs/Makefile</tt> and <tt class="docutils literal">fs/Kconfig</tt>.</p>
+<p>Append the following line to the end of <tt class="docutils literal">fs/Makefile</tt>:</p>
+<pre class="code make literal-block">
+<span class="error">obj-</span><span class="keyword">$(</span>CONFIG_SIMICSFS<span class="keyword">)</span>             +<span class="operator">=</span> simicsfs/
+</pre>
+<p>Add the following line to the end of the section &quot;Miscellaneous
+filesystems&quot; in the <tt class="docutils literal">fs/Kconfig</tt> file:</p>
+<pre class="code make literal-block">
+<span class="error">source</span> <span class="literal string double">&quot;fs/simicsfs/Kconfig&quot;</span>
+</pre>
+</li>
+<li><p class="first">Configure the Linux kernel and select simicsfs as a module.</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>make menuconfig
+File systems  ---&gt;
+Miscellaneous filesystems  ---&gt;
+&lt;M&gt;     Simics hostfs
+</pre>
+<p>Optionally you may set a default physical address, which is described in
+the section <a class="reference internal" href="#how-to-find-and-set-a-physical-address-for-the-driver">How to find and set a physical address for the driver</a>.</p>
+</li>
+<li><p class="first">Compile the kernel and its modules.</p>
+<p>Check the distribution documentation for instructions on how to build the
+Linux kernel; typically it is enough to run <tt class="docutils literal">make</tt> in the
+source code root directory:</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>make
+</pre>
+<p>Or build only the simicsfs module:</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>make <span class="name variable">SUBDIRS</span><span class="operator">=</span>fs/simicsfs modules
+</pre>
+<p>The resulting module file is located at <tt class="docutils literal">fs/simicsfs/simicsfs.ko</tt>.</p>
+<p>See the README file in the Linux source code for more information on how to
+build the kernel.</p>
+</li>
+<li><p class="first">Install the kernel module.</p>
+<p>The module can be either manually inserted into the target system at
+run-time or automatically loaded by the kernel.</p>
+<p>Check the distribution documentation for how to add a kernel module to the
+target file system. Typically it involves placing the module file under
+<tt class="docutils literal"><span class="pre">/lib/modules/`uname</span> <span class="pre">-r`/extra/fs/</span></tt> and running <tt class="docutils literal">depmod</tt>.</p>
+<p>If necessary, see the section <a class="reference internal" href="#how-to-override-the-physical-address-of-the-driver">How to override the physical address of the
+driver</a>.</p>
+<p>To manually load the kernel module at run-time:</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>insmod simicsfs.ko
+</pre>
+<p>See <tt class="docutils literal">man insmod</tt> for more information.</p>
+</li>
+</ol>
+</div>
+<div class="section" id="how-to-find-and-set-a-physical-address-for-the-driver">
+<h1><a class="toc-backref" href="#id4">4&nbsp;&nbsp;&nbsp;How to find and set a physical address for the driver</a></h1>
+<ol class="arabic">
+<li><p class="first">Find a 4 kiB (<tt class="docutils literal">0x1000</tt>) empty region in I/O memory.
+This command is executed on the running target system:
+.. code:: bash</p>
+<blockquote>
+<p>$ cat /proc/iomem</p>
+</blockquote>
+<p>Note that the output is a static snapshot and may not show dynamic usage of
+I/O memory.</p>
+</li>
+<li><p class="first">Check the kernel configuration.</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>grep CONFIG_SIMICSFS_ADDRESS .config
+<span class="name variable">CONFIG_SIMICSFS_ADDRESS</span><span class="operator">=</span><span class="literal string double">&quot;&quot;</span>
+</pre>
+<p>The string will not appear if the driver has not been selected and it will
+be empty unless an address has been explicitly set.</p>
+</li>
+<li><p class="first">Edit the configuration as necessary.</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>make menuconfig
+File systems  ---&gt;
+Miscellaneous filesystems  ---&gt;
+&lt;M&gt;     Simics hostfs
+<span class="operator">()</span>      SimicsFS physical address
+</pre>
+<p>Once the Simics hostfs module has been selected, an option appears where a
+default physical address can be entered. A built-in default value is used
+unless the user specifies a new default address.</p>
+<p>Later, you may want to override the address, see section
+<a class="reference internal" href="#how-to-override-the-physical-address-of-the-driver">How to override the physical address of the driver</a>.</p>
+<p>Remember to save any changes before exiting.</p>
+</li>
+</ol>
+</div>
+<div class="section" id="how-to-override-the-physical-address-of-the-driver">
+<h1><a class="toc-backref" href="#id5">5&nbsp;&nbsp;&nbsp;How to override the physical address of the driver</a></h1>
+<ul>
+<li><p class="first">If the driver was compiled-in (<tt class="docutils literal">&lt;*&gt;</tt> in menuconfig)</p>
+<p>Append this argument to the kernel command-line:</p>
+<pre class="code make literal-block">
+<span class="name variable">simicsfs.phys_addr</span><span class="operator">=</span>0xff00ff00
+</pre>
+</li>
+<li><p class="first">If the driver was compiled as a module (<tt class="docutils literal">&lt;M&gt;</tt> in menuconfig)</p>
+<p>Give an argument when loading the module:</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>insmod simicsfs.ko <span class="name variable">phys_addr</span><span class="operator">=</span>0xff00ff00
+</pre>
+<p>Or by using <tt class="docutils literal">modprobe</tt>, which requires <tt class="docutils literal">depmod</tt> generated files to be
+present on the target system:</p>
+<pre class="code bash literal-block">
+<span class="name variable">$ </span>modprobe simicsfs <span class="name variable">phys_addr</span><span class="operator">=</span>0xff00ff00
+</pre>
+</li>
+</ul>
+<p>Alternatively you can add it as an option in <tt class="docutils literal">/etc/modules.conf</tt>,
+<tt class="docutils literal">/etc/modprobe.conf</tt> or similar, depending on what is provided by your
+target system. Check the distribution documentation.</p>
+</div>
+</div>
+</body>
+</html>
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs.h b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs.h
new file mode 100644
index 0000000..0f81a08
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs.h
@@ -0,0 +1,262 @@
+/*
+   hostfs for Linux
+   Copyright 2001-2006 Virtutech AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef _HOST_FS_H
+#define _HOST_FS_H
+
+#define HOSTFS_VERSION 1
+/* update before release, reset to 99 when done */
+#define HOSTFS_SUBVERSION 21
+
+#if defined(__powerpc__)
+#define HOSTFS_DEV    0xff660000
+#elif defined(__arm__)
+#define HOSTFS_DEV    0x50000000
+#elif defined(__mips__)
+#define HOSTFS_DEV    0x1c000000
+#else
+#define HOSTFS_DEV    0xffe81000
+#endif
+
+#define HOSTFS_MAGIC 0x66685456 	/* "VThf" */
+
+
+
+
+#define DATA_BUF_LEN        1040
+#define HOSTFS_FILENAME_LEN  512
+#define DEBUG_LEN           1024
+#define XFER_DATA_WORDS      256
+
+#define SYMBOL_TO_STRING2(n) #n
+#define SYMBOL_TO_STRING(n) SYMBOL_TO_STRING2(n)
+
+/* used on target */
+#define DPRINT1 if (hostfs_debug >= 1) printk
+#define DPRINT2 if (hostfs_debug >= 2) printk
+
+enum {
+	HF_FREAD = 0x01,
+	HF_FWRITE = 0x02,
+	HF_FNDELAY = 0x04,
+	HF_FAPPEND = 0x08,
+	HF_FSYNC = 0x10
+};
+
+/* only in target part */
+extern dev_t hostfs_dev;
+extern int hostfs_debug;
+
+struct hf_node;
+
+enum host_func {
+	hf_VfsStat,
+	hf_Root,
+	hf_GetAttr,
+	hf_SetAttr,
+	hf_Open,
+	hf_Close,
+	hf_Readdir,
+	hf_Lookup,
+	hf_Seek,
+	hf_Read,
+	hf_Write,
+	hf_Create,
+	hf_Remove,
+	hf_MkDir,
+	hf_Parent,
+	hf_Rename,
+	hf_Link,
+	hf_Symlink,
+	hf_Readlink,
+	hf_Debug,
+	hf_Handshake,
+	hf_Unmount,
+	hf_Functions
+};
+
+struct host_funcs {
+	enum host_func func;
+	const char *name;
+	int out;
+	int in;
+	int ie_out;
+	int ie_in;
+};
+
+/*********
+ *
+ *IMPORTANT:
+ * If you change the parameters make sure the ie_out and ie_in are still
+ * correct. They signal the first entry to do endian conversion on.
+ * -1 is no conversion at all.
+ *
+ */
+
+struct hf_common_data {
+	uint sys_error;
+};
+
+struct hf_hnode_data {
+	uint sys_error;
+	uint hnode;
+	uint type;
+};
+
+struct hf_vfsstat_data {
+	uint bsize;
+	uint frsize;
+	uint blocks;
+	uint bfree;
+	uint bavail;
+	uint files;
+	uint ffree;
+	uint favail;
+};
+
+struct hf_getattr_data {
+	uint sys_error;
+	uint mode;		/* access mode */
+	uint uid;		/* user id */
+	uint gid;		/* group id */
+	uint link;		/* number of references */
+	uint size_hi;		/* file size */
+	uint size_lo;
+	uint atime_hi;		/* access time */
+	uint atime_lo;
+	uint mtime_hi;		/* modification time */
+	uint mtime_lo;
+	uint ctime_hi;		/* creation time */
+	uint ctime_lo;
+	uint blksize;		/* fundamental block size */
+	uint blocks_hi;		/* blocks allocated */
+	uint blocks_lo;
+};
+
+struct hf_setattr_data {
+	uint set_atime;
+	uint set_mtime;
+	uint set_mode;
+	uint set_uid;
+	uint set_gid;
+	uint atime_hi;		/* access time */
+	uint atime_lo;
+	uint mtime_hi;		/* modification time */
+	uint mtime_lo;
+	uint mode;
+	uint uid;
+	uint gid;
+	uint set_size;
+	uint size_hi;
+	uint size_lo;
+};
+
+struct hf_setattr_data_v0 {
+	uint set_atime;
+	uint set_mtime;
+	uint set_mode;
+	uint set_uid;
+	uint set_gid;
+	uint atime_hi;		/* access time */
+	uint atime_lo;
+	uint mtime_hi;		/* modification time */
+	uint mtime_lo;
+	uint mode;
+	uint uid;
+	uint gid;
+};
+
+struct hf_readdir_data {
+	uint sys_error;
+	uint hnode;
+	char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_readlink_data {
+	uint sys_error;
+	char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_lookup_data {
+	char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_remove_data {
+	char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_rename_data {
+	uint new_hnode;
+	char old_name[HOSTFS_FILENAME_LEN];
+	char new_name[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_create_data {
+	uint excl;
+	uint trunc;
+	uint mode;
+	char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_mkdir_data {
+	uint mode;
+	char dirname[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_seek_data {
+	uint off_hi;
+	uint off_lo;
+};
+
+struct hf_read_data {
+	uint sys_error;
+	uint size;
+	uint data[XFER_DATA_WORDS];	/* 1 or 2 KiB of data */
+};
+
+struct hf_write_data {
+	uint size;
+	uint append;
+	uint data[XFER_DATA_WORDS];	/* 1 or 2 KiB of data */
+};
+
+struct hf_link_data {
+	uint hnode;
+	char link[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_symlink_data {
+	char target[HOSTFS_FILENAME_LEN];
+	char link[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_debug_data {
+	char string[DEBUG_LEN];
+};
+
+struct hf_handshake_data {
+	uint version;
+};
+
+struct hf_handshake_reply_data {
+	uint sys_error;
+	uint magic;
+};
+
+#endif				/* _HOST_FS_H */
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_data.h b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_data.h
new file mode 100644
index 0000000..766eeda
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_data.h
@@ -0,0 +1,355 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef _HOST_FS_DATA_H
+#define _HOST_FS_DATA_H
+
+/* WARNING: Only include once. Contains definitions */
+
+/* when transferring data the following protocol is used:
+ *
+ *   to host:  4 byte  function
+ *   to host:  4 bytes hnode
+ *   to host:  X bytes out data (defined by fkn_len[fkn].out)
+ * from host:  X bytes in data  (defined by fkn_len[fkn].in)  ( X > 0 !!! )
+ *
+ */
+
+static struct host_funcs host_funcs[] = {
+	{hf_VfsStat,
+	 "VfsStat",
+	 0,
+	 sizeof(struct hf_vfsstat_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Root,
+	 "Root",
+	 0,
+	 sizeof(struct hf_hnode_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_GetAttr,
+	 "GetAttr",
+	 0,
+	 sizeof(struct hf_getattr_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_SetAttr,
+	 "SetAttr",
+	 sizeof(struct hf_setattr_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Open,
+	 "Open",
+	 1,
+	 sizeof(struct hf_common_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Close,
+	 "Close",
+	 0,
+	 1,
+	 -1,
+	 -1},
+
+	{hf_Readdir,
+	 "Readdir",
+	 1,
+	 sizeof(struct hf_readdir_data) >> 2,
+	 -1,
+	 2},
+
+	{hf_Lookup,
+	 "Lookup",
+	 sizeof(struct hf_lookup_data),
+	 sizeof(struct hf_hnode_data) >> 2,
+	 0,
+	 -1},
+
+	{hf_Seek,
+	 "Seek",
+	 sizeof(struct hf_seek_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Read,
+	 "Read",
+	 1,
+	 sizeof(struct hf_read_data) >> 2,
+	 -1,
+	 2},
+
+	{hf_Write,
+	 "Write",
+	 sizeof(struct hf_write_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 2,
+	 -1},
+
+	{hf_Create,
+	 "Create",
+	 sizeof(struct hf_create_data) >> 2,
+	 sizeof(struct hf_hnode_data) >> 2,
+	 3,
+	 -1},
+
+	{hf_Remove,
+	 "Remove",
+	 sizeof(struct hf_remove_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 0,
+	 -1},
+
+	{hf_MkDir,
+	 "MkDir",
+	 sizeof(struct hf_mkdir_data) >> 2,
+	 sizeof(struct hf_hnode_data) >> 2,
+	 1,
+	 -1},
+
+	{hf_Parent,
+	 "Parent",
+	 0,
+	 sizeof(struct hf_hnode_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Rename,
+	 "Rename",
+	 sizeof(struct hf_rename_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 1,
+	 -1},
+
+	{hf_Link,
+	 "Link",
+	 sizeof(struct hf_link_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 1,
+	 -1},
+
+	{hf_Symlink,
+	 "Symlink",
+	 sizeof(struct hf_symlink_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 0,
+	 -1},
+
+	{hf_Readlink,
+	 "Readlink",
+	 0,
+	 sizeof(struct hf_readlink_data) >> 2,
+	 -1,
+	 1},
+
+	{hf_Debug,
+	 "Debug",
+	 sizeof(struct hf_debug_data) >> 2,
+	 1,
+	 0,
+	 -1},
+
+	{hf_Handshake,
+	 "Handshake",
+	 sizeof(struct hf_handshake_data) >> 2,
+	 sizeof(struct hf_handshake_reply_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Unmount,
+	 "Unmount",
+	 0,
+	 sizeof(struct hf_common_data) >> 2,
+	 -1,
+	 -1}
+};
+
+typedef int check_enough_host_funcs[sizeof(host_funcs) / sizeof(host_funcs[0])
+				    == hf_Functions ? 1 : -1];
+
+#if defined(HOSTFS_HOST)
+static struct host_funcs host_funcs_v0[] = {
+	{hf_VfsStat,
+	 "VfsStat",
+	 0,
+	 sizeof(struct hf_vfsstat_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Root,
+	 "Root",
+	 0,
+	 sizeof(struct hf_hnode_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_GetAttr,
+	 "GetAttr",
+	 0,
+	 sizeof(struct hf_getattr_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_SetAttr,
+	 "SetAttr",
+	 sizeof(struct hf_setattr_data_v0) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Open,
+	 "Open",
+	 1,
+	 sizeof(struct hf_common_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Close,
+	 "Close",
+	 0,
+	 1,
+	 -1,
+	 -1},
+
+	{hf_Readdir,
+	 "Readdir",
+	 1,
+	 sizeof(struct hf_readdir_data) >> 2,
+	 -1,
+	 2},
+
+	{hf_Lookup,
+	 "Lookup",
+	 sizeof(struct hf_lookup_data),
+	 sizeof(struct hf_hnode_data) >> 2,
+	 0,
+	 -1},
+
+	{hf_Seek,
+	 "Seek",
+	 sizeof(struct hf_seek_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Read,
+	 "Read",
+	 1,
+	 sizeof(struct hf_read_data) >> 2,
+	 -1,
+	 2},
+
+	{hf_Write,
+	 "Write",
+	 sizeof(struct hf_write_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 2,
+	 -1},
+
+	{hf_Create,
+	 "Create",
+	 sizeof(struct hf_create_data) >> 2,
+	 sizeof(struct hf_hnode_data) >> 2,
+	 3,
+	 -1},
+
+	{hf_Remove,
+	 "Remove",
+	 sizeof(struct hf_remove_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 0,
+	 -1},
+
+	{hf_MkDir,
+	 "MkDir",
+	 sizeof(struct hf_mkdir_data) >> 2,
+	 sizeof(struct hf_hnode_data) >> 2,
+	 1,
+	 -1},
+
+	{hf_Parent,
+	 "Parent",
+	 0,
+	 sizeof(struct hf_hnode_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Rename,
+	 "Rename",
+	 sizeof(struct hf_rename_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 1,
+	 -1},
+
+	{hf_Link,
+	 "Link",
+	 sizeof(struct hf_link_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 1,
+	 -1},
+
+	{hf_Symlink,
+	 "Symlink",
+	 sizeof(struct hf_symlink_data) >> 2,
+	 sizeof(struct hf_common_data) >> 2,
+	 0,
+	 -1},
+
+	{hf_Readlink,
+	 "Readlink",
+	 0,
+	 sizeof(struct hf_readlink_data) >> 2,
+	 -1,
+	 1},
+
+	{hf_Debug,
+	 "Debug",
+	 sizeof(struct hf_debug_data) >> 2,
+	 1,
+	 0,
+	 -1},
+
+	{hf_Handshake,
+	 "Handshake",
+	 sizeof(struct hf_handshake_data) >> 2,
+	 sizeof(struct hf_handshake_reply_data) >> 2,
+	 -1,
+	 -1},
+
+	{hf_Unmount,
+	 "Unmount",
+	 0,
+	 0,
+	 -1,
+	 -1}
+};
+
+typedef int check_enough_host_funcs_v0[sizeof(host_funcs_v0)
+				       / sizeof(host_funcs_v0[0])
+				       == hf_Functions ? 1 : -1];
+#endif				/* HOSTFS_HOST */
+
+#endif				/* _HOST_FS_DATA */
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_dir.c b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_dir.c
new file mode 100644
index 0000000..22dc533
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_dir.c
@@ -0,0 +1,85 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "hostfs_linux.h"
+
+static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+hostfs_fo_iterate(struct file *file, struct dir_context *ctx)
+#else
+hostfs_fo_readdir(struct file *file, void *buf, filldir_t fill)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+	struct dentry *dentry = file->f_path.dentry;
+#else
+	struct dentry *dentry = file->f_dentry;
+#endif
+	struct inode *inode = dentry->d_inode;
+	struct hf_readdir_data data;
+	uint offset = file->f_pos;
+
+/*	DPRINT1(DEVICE_NAME " hostfs_fo_readdir("); */
+/*	DPRINTFILE1(file); */
+/*	DPRINT1(", %p, %p)\n", buf, fill); */
+/*	DPRINT1("	file->fpos == %ld\n", (long)file->f_pos); */
+
+	get_host_data(hf_Readdir, inode->i_ino, &offset, &data);
+	while (data.hnode) {
+		NTOHSWAP(data.filename);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+		if (!dir_emit(ctx, data.filename, strlen(data.filename),
+			      data.hnode, DT_UNKNOWN))
+			return 0;
+		ctx->pos = ++offset;
+#else
+		if (fill(buf, data.filename, strlen(data.filename), offset,
+			 data.hnode, DT_UNKNOWN) < 0)
+			return 0;
+		file->f_pos = ++offset;
+#endif
+		get_host_data(hf_Readdir, inode->i_ino, &offset, &data);
+	}
+	return 0;
+}
+
+static ssize_t
+hostfs_fo_dir_read(struct file *file, char *buf, size_t len, loff_t *off)
+{
+/*	DPRINT1(DEVICE_NAME " hostfs_fo_dir_read()\n"); */
+	return -EISDIR;
+}
+
+static int hostfs_dir_release(struct inode *inode, struct file *file)
+{
+	uint dummy;
+	get_host_data(hf_Close, inode->i_ino, NULL, &dummy);
+	return 0;
+}
+
+const struct file_operations hostfs_file_dirops = {
+	.read = hostfs_fo_dir_read,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+	.iterate = hostfs_fo_iterate,
+#else
+	.readdir = hostfs_fo_readdir,
+#endif
+	.release = hostfs_dir_release,
+};
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_file.c b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_file.c
new file mode 100644
index 0000000..d3691cd
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_file.c
@@ -0,0 +1,169 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "hostfs_linux.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+#define f_dentry        f_path.dentry
+#endif
+
+static int hostfs_fo_open(struct inode *inode, struct file *file)
+{
+	struct hf_common_data idata;
+	uint oflag = 0, flag = file->f_flags;
+
+	DPRINT1("hostfs_fo_open %ld flags %x\n", inode->i_ino, file->f_flags);
+
+	switch (flag & O_ACCMODE) {
+	case O_RDONLY:
+		oflag = HF_FREAD;
+		break;
+	case O_RDWR:
+		oflag = HF_FREAD;
+		/* fallthrough */
+	case O_WRONLY:
+		oflag |= HF_FWRITE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	get_host_data(hf_Open, inode->i_ino, &oflag, &idata);
+
+	if (idata.sys_error)
+		return -idata.sys_error;
+
+	return 0;
+}
+
+static int hostfs_fo_release(struct inode *inode, struct file *file)
+{
+	uint dummy;
+
+	/* DPRINT1("hostfs_fo_release %ld fcount %d icount %d\n",
+	   (long)inode->i_ino, atomic_read(&file->f_count),
+	   atomic_read(&inode->i_count)); */
+
+	get_host_data(hf_Close, inode->i_ino, NULL, &dummy);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)
+static ssize_t
+hostfs_read(struct file *file, char *buf, size_t len, loff_t *ppos)
+{
+	DPRINT1("hostfs: hostfs_read %ld\n", file->f_dentry->d_inode->i_ino);
+	if (!hostfs_revalidate_inode(file->f_dentry->d_inode))
+		return 0;
+	return do_sync_read(file, buf, len, ppos);
+}
+
+static ssize_t
+hostfs_write(struct file *file, const char *buf, size_t len, loff_t *ppos)
+{
+	DPRINT1("hostfs: hostfs_write %ld\n", file->f_dentry->d_inode->i_ino);
+	if (!hostfs_revalidate_inode(file->f_dentry->d_inode))
+		return 0;
+	return do_sync_write(file, buf, len, ppos);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static ssize_t
+hostfs_aio_read(struct kiocb *kiocb, char *buf, size_t len, loff_t ppos)
+{
+	DPRINT1("hostfs: hostfs_aio_read %ld\n",
+		kiocb->ki_filp->f_dentry->d_inode->i_ino);
+	if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
+		return 0;
+	return generic_file_aio_read(kiocb, buf, len, ppos);
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0)
+static ssize_t
+hostfs_aio_read(struct kiocb *kiocb, const struct iovec *iovec,
+		unsigned long len, loff_t ofs)
+{
+	DPRINT1("hostfs: hostfs_aio_read %ld\n",
+		kiocb->ki_filp->f_dentry->d_inode->i_ino);
+	if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
+		return 0;
+	return generic_file_aio_read(kiocb, iovec, len, ofs);
+}
+#else
+static ssize_t
+hostfs_iter_read(struct kiocb *kiocb, struct iov_iter *to)
+{
+	DPRINT1("hostfs: hostfs_iter_read %ld\n",
+		kiocb->ki_filp->f_dentry->d_inode->i_ino);
+	if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
+		return 0;
+	return generic_file_read_iter(kiocb, to);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static ssize_t
+hostfs_aio_write(struct kiocb *kiocb, const char *buf, size_t len, loff_t ppos)
+{
+	DPRINT1("hostfs: hostfs_aio_write %ld\n",
+		kiocb->ki_filp->f_dentry->d_inode->i_ino);
+	if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
+		return 0;
+	return generic_file_aio_write(kiocb, buf, len, ppos);
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0)
+static ssize_t
+hostfs_aio_write(struct kiocb *kiocb, const struct iovec *iovec,
+		 unsigned long len, loff_t ofs)
+{
+	DPRINT1("hostfs: hostfs_aio_write %ld\n",
+		kiocb->ki_filp->f_dentry->d_inode->i_ino);
+	if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
+		return 0;
+	return generic_file_aio_write(kiocb, iovec, len, ofs);
+}
+#else
+static ssize_t
+hostfs_iter_write(struct kiocb *kiocb, struct iov_iter *from)
+{
+	DPRINT1("hostfs: hostfs_iter_write %ld\n",
+		kiocb->ki_filp->f_dentry->d_inode->i_ino);
+	if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
+		return 0;
+	return generic_file_write_iter(kiocb, from);
+}
+#endif
+
+const struct file_operations hostfs_file_fops = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)
+	.read = hostfs_read,
+	.write = hostfs_write,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0)
+	.aio_read = hostfs_aio_read,
+	.aio_write = hostfs_aio_write,
+#else
+	.read_iter = hostfs_iter_read,
+	.write_iter = hostfs_iter_write,
+#endif
+	.mmap = generic_file_mmap,
+	.open = hostfs_fo_open,
+	.release = hostfs_fo_release,
+};
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_host.c b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_host.c
new file mode 100644
index 0000000..18d3724
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_host.c
@@ -0,0 +1,146 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "hostfs_linux.h"
+#include <linux/moduleparam.h>
+
+#if !defined(__sparc_v9__)
+static volatile void *hostfs_dev_data;
+#endif
+
+static void write_value(uint value)
+{
+#if defined(__sparc_v9__)
+	asm volatile ("wr %0, 0, %%asr31"::"r" (value));
+#else
+	writel(value, hostfs_dev_data);
+#endif
+}
+
+static uint read_value(void)
+{
+	uint value;
+#if defined(__sparc_v9__)
+	asm volatile ("rd %%asr31, %0":"=r" (value));
+#else
+	value = readl(hostfs_dev_data);
+#endif
+	return value;
+}
+
+static void data_to_host(uint *data, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++)
+		write_value(data[i]);
+}
+
+static void data_from_host(uint *data, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++)
+		data[i] = read_value();
+}
+
+spinlock_t get_host_data_lock;
+spinlock_t hostfs_position_lock;
+
+int get_host_data(enum host_func func, uint hnode, void *in_buf, void *out_buf)
+{
+	uint data;
+
+	if (func != host_funcs[func].func)
+		printk(DEVICE_NAME
+		       " INTERNAL ERROR: enum host_funcs != func\n");
+
+	spin_lock(&get_host_data_lock);
+
+	data = func;
+	data_to_host(&data, 1);
+	data_to_host(&hnode, 1);
+	data_to_host(in_buf, host_funcs[func].out);
+	data_from_host(out_buf, host_funcs[func].in);
+
+	spin_unlock(&get_host_data_lock);
+
+	return 0;
+}
+
+/* internal function */
+int hf_do_seek(ino_t inode, loff_t off)
+{
+	struct hf_seek_data odata;
+	struct hf_common_data idata;
+
+	SET_HI_LO(odata.off, off);
+	get_host_data(hf_Seek, inode, &odata, &idata);
+	return idata.sys_error;
+}
+
+/*
+ * Dynamic configuration support.
+ * You can specify simicsfs.phys_addr=0xff00ff00 on the kernel command line, or
+ * insmod simicsfs phys_addr=0xff00ff00
+ */
+
+static char *phys_addr = "0xffff0000";
+
+module_param(phys_addr, charp, 0);
+MODULE_PARM_DESC(phys_addr, "Physical address where simicsfs is mapped.");
+
+int init_host_fs(void)
+{
+	unsigned long long hostfs_dev = HOSTFS_DEV;
+
+	if (phys_addr && strcmp(phys_addr, "") != 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)
+		hostfs_dev = simple_strtoull(phys_addr, NULL, 0);
+#else
+		if (kstrtoull(phys_addr, 0, &hostfs_dev))
+			return -EINVAL;
+#endif
+
+#if defined(__alpha)
+	hostfs_dev_data = (void *)phys_to_virt(hostfs_dev);
+#elif defined(__i386) || defined(__x86_64__) || defined(__ia64) \
+	|| defined(__powerpc__) || defined(__arm__) || defined(__mips__) \
+	|| defined(__m68k__)
+#ifdef CONFIG_440
+	hostfs_dev_data = (void *)ioremap64(hostfs_dev, 16);
+#else
+	hostfs_dev_data = (void *)ioremap(hostfs_dev, 16);
+#endif
+	if (!hostfs_dev_data) {
+		printk(KERN_ERR "hostfs: cannot map 0x%08llx\n", hostfs_dev);
+		return -EIO;
+	}
+	printk(KERN_INFO "Mapping hostfs from p:%08llx to %p\n",
+	       hostfs_dev, hostfs_dev_data);
+#elif defined(__sparc_v9__)
+#else
+#error "No device mapping for this architecture"
+#endif
+
+	spin_lock_init(&get_host_data_lock);
+	spin_lock_init(&hostfs_position_lock);
+	return 0;
+}
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_inode.c b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_inode.c
new file mode 100644
index 0000000..900e80e
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_inode.c
@@ -0,0 +1,763 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "hostfs_linux.h"
+#include <linux/slab.h>		/* for kmalloc/kfree */
+#include <linux/namei.h>	/* nd_set_link */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+# ifndef PAGE_CACHE_SHIFT
+#  define PAGE_CACHE_SHIFT PAGE_SHIFT
+# endif
+# ifndef PAGE_CACHE_SIZE
+#  define PAGE_CACHE_SIZE PAGE_SIZE
+# endif
+#endif /* LINUX_VERSION_CODE >= 4.6 */
+
+static const struct address_space_operations hostfs_file_aops;
+static struct inode_operations hostfs_symlink_iops;
+static struct inode_operations hostfs_dir_iops;
+static struct inode_operations hostfs_file_iops;
+
+int hostfs_revalidate_inode(struct inode *inode)
+{
+	struct inode updated_inode = *inode;
+
+	DPRINT1("hostfs_revalidate %ld\n", (long)inode->i_ino);
+
+	hostfs_read_inode(&updated_inode);
+
+	if (memcmp(&updated_inode, inode, sizeof(updated_inode)) != 0) {
+		DPRINT1("hostfs: inode changed, flushing pages\n");
+		memcpy(inode, &updated_inode, sizeof(updated_inode));
+
+		/* TODO: can we do a better guess when to invalidate pages and
+		   when not to? */
+		invalidate_inode_pages2(inode->i_mapping);
+	} else {
+		DPRINT1("hostfs: inode not changed\n");
+	}
+	return 1;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+struct inode *hostfs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	hostfs_read_inode(inode);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+#endif
+
+void hostfs_read_inode(struct inode *inode)
+{
+	struct hf_getattr_data data;
+	uint mask;
+
+	get_host_data(hf_GetAttr, inode->i_ino, &mask, &data);
+	if (data.sys_error) {
+		printk(DEVICE_NAME
+		       "get_host_data(hf_GetAttr, %ld, ...) had an error\n",
+		       inode->i_ino);
+		return;
+	}
+
+	DPRINT1("hostfs_read_inode(%ld) flags %lx\n", inode->i_ino,
+		(long)inode->i_flags);
+
+	inode->i_flags = 0;
+	inode->i_mode = data.mode;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+	inode->i_uid = data.uid;
+	inode->i_gid = data.gid;
+#else
+	inode->i_uid = KUIDT_INIT(data.uid);
+	inode->i_gid = KGIDT_INIT(data.gid);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	set_nlink(inode, data.link);
+#else
+	inode->i_nlink = data.link;
+#endif
+	GET_HI_LO(inode->i_size, data.size);
+	GET_HI_LO(inode->i_atime.tv_sec, data.atime);
+	GET_HI_LO(inode->i_mtime.tv_sec, data.mtime);
+	GET_HI_LO(inode->i_ctime.tv_sec, data.ctime);
+	inode->i_atime.tv_nsec = 0;
+	inode->i_mtime.tv_nsec = 0;
+	inode->i_ctime.tv_nsec = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	/* blksize field completely removed in 2.6.19 */
+	inode->i_blksize = data.blksize;
+#endif
+	GET_HI_LO(inode->i_blocks, data.blocks);
+
+	if (S_ISLNK(inode->i_mode)) {
+		inode->i_op = &hostfs_symlink_iops;
+	} else if (S_ISDIR(inode->i_mode)) {
+		inode->i_op = &hostfs_dir_iops;
+		inode->i_fop = &hostfs_file_dirops;
+	} else {
+		inode->i_fop = &hostfs_file_fops;
+		inode->i_op = &hostfs_file_iops;
+		inode->i_mapping->a_ops = &hostfs_file_aops;
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+int hostfs_write_inode(struct inode *inode, struct writeback_control *wbc)
+#else
+int hostfs_write_inode(struct inode *inode, int sync)
+#endif
+{
+	/*
+	 * it might be pointless to implement this function since
+	 * supposedly all changes will have been updated by
+	 * notify_change anyway, but I'm sure it can't hurt
+	 */
+
+	struct hf_setattr_data odata;
+	struct hf_common_data idata;
+
+	DPRINT1(DEVICE_NAME " hostfs_write_inode(%ld)\n", inode->i_ino);
+
+	memset(&odata, 0, sizeof(odata));
+	odata.set_atime = 1;
+	SET_HI_LO(odata.atime, inode->i_atime.tv_sec);
+	SET_HI_LO(odata.mtime, inode->i_mtime.tv_sec);
+	odata.set_mtime = 1;
+	odata.set_mode = 1;
+	odata.mode = inode->i_mode;
+	odata.set_uid = 1;
+	odata.set_gid = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+	odata.uid = inode->i_uid;
+	odata.gid = inode->i_gid;
+#else
+	odata.uid = from_kuid_munged(NULL, inode->i_uid);
+	odata.gid = from_kgid_munged(NULL, inode->i_gid);
+#endif
+	get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
+	return 0;
+}
+
+static int hostfs_setattr(struct dentry *dentry, struct iattr *iattr)
+{
+	struct hf_setattr_data odata;
+	struct hf_common_data idata;
+	struct inode *inode = dentry->d_inode;
+	int error;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	int setsize = 0;
+#endif
+
+	DPRINT1(DEVICE_NAME " hostfs_notify_change(%ld, 0x%lx)\n",
+		inode->i_ino, (long)iattr->ia_valid);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+        error = setattr_prepare(dentry, iattr);
+#else
+	error = inode_change_ok(inode, iattr);
+#endif
+	if (error)
+		return error;
+
+	memset(&odata, 0, sizeof(odata));
+	if (iattr->ia_valid & ATTR_ATIME) {
+		odata.set_atime = 1;
+		SET_HI_LO(odata.atime, iattr->ia_atime.tv_sec);
+	}
+	if (iattr->ia_valid & ATTR_MTIME) {
+		odata.set_mtime = 1;
+		SET_HI_LO(odata.mtime, iattr->ia_mtime.tv_sec);
+	}
+	if (iattr->ia_valid & ATTR_MODE) {
+		odata.set_mode = 1;
+		odata.mode = iattr->ia_mode;
+	}
+	if (iattr->ia_valid & ATTR_UID) {
+		odata.set_uid = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+		odata.uid = iattr->ia_uid;
+#else
+		odata.uid = from_kuid_munged(NULL, iattr->ia_uid);
+#endif
+	}
+	if (iattr->ia_valid & ATTR_GID) {
+		odata.set_gid = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+		odata.gid = iattr->ia_gid;
+#else
+		odata.gid = from_kgid_munged(NULL, iattr->ia_gid);
+#endif
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	if (iattr->ia_valid & ATTR_SIZE && iattr->ia_size != inode->i_size) {
+		setsize = 1;
+		odata.set_size = 1;
+		SET_HI_LO(odata.size, iattr->ia_size);
+	}
+#endif
+	get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
+
+	DPRINT1("         hf_SetAttr returned %d\n", idata.sys_error);
+
+	if (idata.sys_error)
+		return -idata.sys_error;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	if (setsize)
+		truncate_setsize(inode, iattr->ia_size);
+	setattr_copy(inode, iattr);
+	mark_inode_dirty(inode);
+	return 0;
+#else
+	return inode_setattr(inode, iattr);
+#endif
+}
+
+static int
+hostfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+	DPRINT1("hostfs: getattr\n");
+	if (!hostfs_revalidate_inode(dentry->d_inode))
+		return 0;
+	generic_fillattr(dentry->d_inode, stat);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+static int
+hostfs_write_begin(struct file *file, struct address_space *mapping,
+		   loff_t pos, unsigned len, unsigned flags,
+		   struct page **pagep, void **fsdata)
+{
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 28)
+	struct page *page = grab_cache_page(mapping, index);
+#else
+	struct page *page = grab_cache_page_write_begin(mapping, index, flags);
+#endif
+
+	*pagep = page;
+	if (page == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+#else
+static int
+hostfs_prepare_write(struct file *file, struct page *page, unsigned offset,
+		     unsigned to)
+{
+	return 0;
+}
+#endif
+
+static int
+hostfs_do_writepage(struct inode *inode, struct page *page, unsigned from,
+		    unsigned to)
+{
+	int offset = (page->index << PAGE_CACHE_SHIFT) + from;
+	unsigned bytes = to - from;
+	unsigned long int address = (unsigned long)page_address(page) + from;
+	uint ino = inode->i_ino;
+	int res;
+	struct hf_write_data *odata;
+
+	if (page->index > (0x7fffffff / PAGE_CACHE_SIZE) - 1)
+		return -EFBIG;
+
+	/* It is risky to allocate the write buffer on the stack since we
+	   have limited stack space */
+	odata = kmalloc(sizeof(*odata), GFP_KERNEL);
+
+	if (!odata)
+		return -ENOMEM;
+
+	spin_lock(&hostfs_position_lock);
+
+	DPRINT1("hostfs_do_writepage: ino:%u offset:%u bytes:%u address:%lx\n",
+		ino, offset, bytes, address);
+
+	hf_do_seek(ino, offset);
+
+	res = 0;
+	while (bytes > 0) {
+		struct hf_common_data idata;
+		uint cnt = MIN(bytes, XFER_DATA_WORDS * 4);
+		odata->append = 0;
+		odata->size = cnt;
+		memcpy(odata->data, (char *)address, cnt);
+		HTONSWAP(odata->data);
+		get_host_data(hf_Write, ino, odata, &idata);
+		if (idata.sys_error) {
+			res = -idata.sys_error;
+			DPRINT1(DEVICE_NAME " failed with errcode %d\n", res);
+			SetPageError(page);
+			ClearPageUptodate(page);
+			goto got_error;
+		}
+		address += cnt;
+		bytes -= cnt;
+		res += cnt;
+	}
+	DPRINT1(DEVICE_NAME "wrote %d bytes\n", (int)res);
+
+	SetPageUptodate(page);
+
+got_error:
+	kfree(odata);
+	spin_unlock(&hostfs_position_lock);
+
+	return res;
+}
+
+static int hostfs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	struct inode *inode = page->mapping->host;
+	int err = -EIO;
+	int bytes = PAGE_CACHE_SIZE;
+	unsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;
+	if (page->index <= end_index) {
+		if (page->index == end_index)
+			bytes = inode->i_size & (PAGE_CACHE_SIZE - 1);
+		kmap(page);
+		err = hostfs_do_writepage(inode, page, 0, bytes);
+		kunmap(page);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	unlock_page(page);
+#else
+	ClearPageLocked(page);
+#endif
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+static int
+hostfs_write_end(struct file *file, struct address_space *mapping,
+		 loff_t pos, unsigned len, unsigned copied,
+		 struct page *page, void *fsdata)
+{
+	unsigned from = pos & (PAGE_CACHE_SIZE - 1);
+	unsigned to = from + copied;
+
+	struct inode *inode = mapping->host;
+	int err;
+
+	kmap(page);
+	err = hostfs_do_writepage(inode, page, from, to);
+
+	if (err >= 0) {
+		loff_t s = ((page->index) << PAGE_CACHE_SHIFT) + to;
+		if (s > inode->i_size)
+			inode->i_size = s;
+	}
+
+	kunmap(page);
+
+	unlock_page(page);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+        put_page(page);
+#else
+	page_cache_release(page);
+#endif
+	return err;
+}
+
+#else
+
+static int
+hostfs_commit_write(struct file *file, struct page *page, unsigned from,
+		    unsigned to)
+{
+	struct inode *inode = page->mapping->host;
+	int err;
+
+	kmap(page);
+	err = hostfs_do_writepage(inode, page, from, to);
+	kunmap(page);
+
+	if (err < 0)
+		return err;
+
+	{
+		loff_t s = ((page->index) << PAGE_CACHE_SHIFT) + to;
+		if (s > inode->i_size)
+			inode->i_size = s;
+	}
+	return 0;
+}
+#endif
+
+static int hostfs_inode_readpage(struct file *file, struct page *page)
+{
+	char *address;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+	struct inode *inode = file->f_path.dentry->d_inode;
+#else
+	struct inode *inode = file->f_dentry->d_inode;
+#endif
+	uint count = PAGE_CACHE_SIZE;
+	int err;
+	struct hf_read_data *data;
+
+	if (page->index > (0xffffffff / PAGE_CACHE_SIZE) - 1)
+		return -EFBIG;
+
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	ClearPageError(page);
+	count = PAGE_SIZE;
+
+	address = kmap(page);
+
+	DPRINT2("readpage ino %lu page %ld (address %p)\n",
+		inode->i_ino, page->index, address);
+
+	spin_lock(&hostfs_position_lock);
+
+	err = hf_do_seek(inode->i_ino, page->index << PAGE_CACHE_SHIFT);
+	if (err) {
+		err = -err;
+		goto out_error;
+	}
+
+	while (count > 0) {
+		uint to_read = MIN(count, XFER_DATA_WORDS * 4);
+
+		get_host_data(hf_Read, inode->i_ino, &to_read, data);
+		if (data->sys_error) {
+			err = -data->sys_error;
+			goto out_error;
+		}
+
+		DPRINT2("readpage count %u out of %lu\n", count, PAGE_SIZE);
+
+		if (!data->size) {
+			memset(address, 0, count);
+			break;
+		}
+
+		NTOHSWAP(data->data);
+
+		memcpy(address, data->data, data->size);
+
+		address += data->size;
+		count -= data->size;
+	}
+
+	err = 0;
+	spin_unlock(&hostfs_position_lock);
+
+	SetPageUptodate(page);
+out_error:
+	kfree(data);
+
+	if (err)
+		SetPageError(page);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	unlock_page(page);
+#else
+	ClearPageLocked(page);
+#endif
+	kunmap(page);
+
+	return err;
+}
+
+static int hostfs_inode_readlink(struct dentry *dentry, char *buf, int size)
+{
+	struct hf_readlink_data data;
+
+	get_host_data(hf_Readlink, dentry->d_inode->i_ino, NULL, &data);
+	if (data.sys_error)
+		return -data.sys_error;
+	NTOHSWAP(data.filename);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
+	return vfs_readlink(dentry, buf, size, data.filename);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
+	return readlink_copy(buf, size, data.filename);
+#else
+	return generic_readlink(dentry, buf, size);
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
+static void *
+#else
+static int
+#endif
+hostfs_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	struct hf_readlink_data data;
+	char *name;
+	int ret_val;
+
+	DPRINT2("hostfs_inode_follow_link(ino %ld)\n", dentry->d_inode->i_ino);
+
+	get_host_data(hf_Readlink, dentry->d_inode->i_ino, NULL, &data);
+	if (data.sys_error)
+		name = ERR_PTR(-data.sys_error);
+	else {
+		name = data.filename;
+		NTOHSWAP(data.filename);
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+	nd_set_link(nd, data.filename);
+	ret_val = 0;
+#else
+	ret_val = vfs_follow_link(nd, data.filename);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
+	return ERR_PTR(ret_val);
+#else
+	return ret_val;
+#endif
+}
+#endif /* kernel < 4.2.0 */
+
+static struct dentry *
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+hostfs_inode_lookup(struct inode *dir, struct dentry *dentry, unsigned flags)
+#else
+hostfs_inode_lookup(struct inode *dir, struct dentry *dentry,
+		    struct nameidata *name_data)
+#endif
+{
+	struct hf_lookup_data odata;
+	struct hf_hnode_data idata;
+	struct inode *inode;
+
+	DPRINT2("hostfs_inode_lookup(%ld, dent %p = %s)\n", dir->i_ino, dentry,
+		dentry->d_name.name);
+
+	/* protect lots of stupid strcpy()s */
+	if (dentry->d_name.len > HOSTFS_FILENAME_LEN - 1)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	memcpy(odata.filename, dentry->d_name.name, dentry->d_name.len);
+	odata.filename[dentry->d_name.len] = 0;
+	HTONSWAP(odata.filename);
+	get_host_data(hf_Lookup, dir->i_ino, &odata, &idata);
+
+	if (idata.sys_error) {
+		if (idata.sys_error != ENOENT)
+			return ERR_PTR(-idata.sys_error);
+		inode = NULL;
+	} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+		inode = hostfs_iget(dir->i_sb, idata.hnode);
+#else
+		inode = iget(dir->i_sb, idata.hnode);
+#endif
+	}
+
+	d_add(dentry, inode);
+
+	return ERR_PTR(0);
+}
+
+static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+hostfs_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
+#else
+hostfs_inode_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	struct hf_mkdir_data odata;
+	struct hf_hnode_data idata;
+	struct inode *inode;
+
+	DPRINT1("hostfs_inode_mkdir()\n");
+
+	odata.mode = mode;
+	strcpy(odata.dirname, dentry->d_name.name);
+	HTONSWAP(odata.dirname);
+
+	get_host_data(hf_MkDir, dir->i_ino, &odata, &idata);
+	if (idata.sys_error)
+		return -idata.sys_error;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	inode = hostfs_iget(dir->i_sb, idata.hnode);
+#else
+	inode = iget(dir->i_sb, idata.hnode);
+	hostfs_read_inode(inode);
+#endif
+	mark_inode_dirty(inode);
+	d_instantiate(dentry, inode);
+
+	return 0;
+}
+
+static int hostfs_inode_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct hf_remove_data odata;
+	struct hf_common_data idata;
+
+	DPRINT1("hostfs_inode_rmdir()\n");
+
+	strcpy(odata.filename, dentry->d_name.name);
+	HTONSWAP(odata.filename);
+	get_host_data(hf_Remove, dir->i_ino, &odata, &idata);
+	mark_inode_dirty(dir);
+
+	return -idata.sys_error;
+}
+
+static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+hostfs_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+		    bool excl)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+hostfs_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+		    bool excl)
+#else
+hostfs_inode_create(struct inode *dir, struct dentry *dentry, int mode,
+		    struct nameidata *name_data)
+#endif
+{
+	struct hf_create_data odata;
+	struct hf_hnode_data idata;
+	struct inode *inode;
+
+	DPRINT1("hostfs_inode_create(%ld, mode = %d)\n", dir->i_ino, mode);
+
+	odata.mode = mode & S_IALLUGO;
+	odata.excl = 0;
+	odata.trunc = 0;
+	strncpy(odata.filename, dentry->d_name.name, sizeof(odata.filename));
+	HTONSWAP(odata.filename);
+
+	get_host_data(hf_Create, dir->i_ino, &odata, &idata);
+
+	if (idata.sys_error)
+		return -idata.sys_error;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	inode = hostfs_iget(dir->i_sb, idata.hnode);
+#else
+	inode = iget(dir->i_sb, idata.hnode);
+	hostfs_read_inode(inode);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+	DPRINT1("    read inode mode 0%o  uid %d\n", inode->i_mode,
+		inode->i_uid);
+#else
+	DPRINT1("    read inode mode 0%o  uid %d\n", inode->i_mode,
+		from_kuid_munged(NULL, inode->i_uid));
+#endif
+	mark_inode_dirty(inode);
+	d_instantiate(dentry, inode);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+static void hostfs_inode_truncate(struct inode *inode)
+{
+	struct hf_setattr_data odata;
+	struct hf_common_data idata;
+
+	DPRINT1("hostfs_inode_truncate(inode = %ld)\n", inode->i_ino);
+
+	memset(&odata, 0, sizeof(odata));
+	odata.set_size = 1;
+	SET_HI_LO(odata.size, inode->i_size);
+	get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
+
+	if (idata.sys_error)
+		printk(KERN_WARNING
+		       "[hostfs] call to truncate() failed with error %d!\n",
+		       idata.sys_error);
+}
+#endif
+
+static int hostfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct hf_remove_data odata;
+	struct hf_common_data idata;
+
+	DPRINT1("hostfs_unlink(dir = %ld, dentry = %s)\n", dir->i_ino,
+		dentry->d_name.name);
+
+	strcpy(odata.filename, dentry->d_name.name);
+	HTONSWAP(odata.filename);
+	get_host_data(hf_Remove, dir->i_ino, &odata, &idata);
+
+	return -idata.sys_error;
+}
+
+static struct inode_operations hostfs_dir_iops = {
+	.create = hostfs_inode_create,
+	.lookup = hostfs_inode_lookup,
+	.unlink = hostfs_unlink,
+	.mkdir = hostfs_inode_mkdir,
+	.rmdir = hostfs_inode_rmdir,
+};
+
+static struct inode_operations hostfs_symlink_iops = {
+	.readlink = hostfs_inode_readlink,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+	.follow_link = hostfs_inode_follow_link,
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)
+	.follow_link = simple_follow_link,
+#else
+	.get_link = simple_get_link,
+#endif
+};
+
+static struct inode_operations hostfs_file_iops = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+	.truncate = hostfs_inode_truncate,
+#endif
+	.setattr = hostfs_setattr,
+	.getattr = hostfs_getattr,
+};
+
+static const struct address_space_operations hostfs_file_aops = {
+	.readpage = hostfs_inode_readpage,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	.write_begin = hostfs_write_begin,
+	.write_end = hostfs_write_end,
+#else
+	.prepare_write = hostfs_prepare_write,
+	.commit_write = hostfs_commit_write,
+#endif
+	.writepage = hostfs_writepage,
+};
+
+MODULE_LICENSE("GPL");
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_linux.h b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_linux.h
new file mode 100644
index 0000000..ff38e66
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_linux.h
@@ -0,0 +1,129 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef HOSTFS_H
+#define HOSTFS_H 1
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+  /* linux/config.h has been deprecated way before 2.6.19, but has at least
+     worked. Starting with 2.6.19 it does not */
+#include <linux/config.h>
+#endif
+
+#define DEVICE_NAME "[simicsfs]"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+#error "Unsupported kernel version"
+#endif
+
+#include <linux/sched.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/aio.h>
+#include <linux/unistd.h>
+#include <linux/errno.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
+#include <asm/io.h>
+#else
+#include <linux/io.h>
+#endif
+#include <linux/init.h>
+#include <linux/statfs.h>
+
+#define TARGETOS_LINUX
+#include "hostfs.h"
+#include "hostfs_data.h"
+
+#define GET_HI_LO(tgt, src) do {					  \
+	typedef int check_tgt_size[sizeof(tgt) == 8 || sizeof(tgt) == 4	  \
+				   ? 1 : -1] __attribute__((unused));	  \
+	if (sizeof(tgt) == 4)						  \
+		tgt = src ## _lo;					  \
+	else if (sizeof(tgt) == 8) {					  \
+		tgt = src ## _hi;					  \
+		tgt <<= 16;						  \
+		tgt <<= 16;						  \
+		tgt |= src ## _lo;					  \
+	}								  \
+} while (0)
+
+#define SET_HI_LO(tgt, src) do {					  \
+	typedef int check_src_size[sizeof(src) == 8 || sizeof(src) == 4	  \
+				   ? 1 : -1] __attribute__((unused));	  \
+	if (sizeof(src) == 4) {						  \
+		tgt ## _lo = src;					  \
+		tgt ## _hi = 0;						  \
+	} else if (sizeof(src) == 8) {					  \
+		unsigned long long tmp = src;				  \
+		tgt ## _lo = (uint)src;					  \
+		tgt ## _hi = tmp >> 32;					  \
+	}								  \
+} while (0)
+
+#define DEBUG_LEVEL 0
+#define HOSTFS_BLOCK_BITS 10
+#define HOSTFS_BLOCK_SIZE (1 << HOSTFS_BLOCK_BITS)
+
+#define HOSTFS_ROOT_INO 1
+
+#define DPRINTINODE1(inode) do {			\
+	if (DEBUG_LEVEL >= 1)				\
+		print_inode(inode);			\
+} while (0)
+
+#define DPRINTFILE1(file) do { } while (0)
+
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+#define NTOHSWAP(field) do {						\
+	int __i;							\
+	for (__i = 0; __i < (sizeof(field) + 3) / 4; ++__i) {		\
+		((uint *)&field)[__i] = ntohl(((uint *)&field)[__i]);	\
+	}								\
+} while (0)
+
+#define HTONSWAP(field) NTOHSWAP(field)
+
+extern const struct file_operations hostfs_file_fops;
+extern const struct file_operations hostfs_file_dirops;
+
+int hostfs_revalidate_inode(struct inode *inode);
+void hostfs_read_inode(struct inode *inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+int hostfs_write_inode(struct inode *inode, struct writeback_control *wbc);
+#else
+int hostfs_write_inode(struct inode *inode, int sync);
+#endif
+
+extern spinlock_t get_host_data_lock;
+extern spinlock_t hostfs_position_lock;
+
+/* host interface */
+int get_host_data(enum host_func func, uint hnode, void *in_buf, void *out_buf);
+int hf_do_seek(ino_t inode, loff_t off);
+int init_host_fs(void);
+
+#endif
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_super.c b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_super.c
new file mode 100644
index 0000000..fbc2856
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/files/hostfs_super.c
@@ -0,0 +1,164 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "hostfs_linux.h"
+#include <linux/moduleparam.h>
+
+static struct super_operations hostfs_super_ops;
+
+int hostfs_debug;
+module_param(hostfs_debug, int, 0);
+MODULE_PARM_DESC(hostfs_debug, "A debug level integer, default off (0)");
+
+static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+hostfs_statfs(struct dentry *de, struct kstatfs *buf)
+#else
+hostfs_statfs(struct super_block *sb, struct kstatfs *buf)
+#endif
+{
+	struct hf_vfsstat_data data;
+
+	get_host_data(hf_VfsStat, 0, NULL, &data);
+
+	memset(buf, 0, sizeof(*buf));
+	buf->f_type = HOSTFS_MAGIC;
+	buf->f_bsize = data.bsize;
+	buf->f_blocks = data.blocks;
+	buf->f_bfree = data.bfree;
+	buf->f_bavail = data.bavail;
+	buf->f_files = data.files;
+	buf->f_ffree = data.ffree;
+	buf->f_namelen = HOSTFS_FILENAME_LEN;
+
+	return 0;
+}
+
+static int hostfs_read_super(struct super_block *sb, void *data, int silent)
+{
+	struct inode *root_inode;
+	struct hf_handshake_data odata;
+	struct hf_handshake_reply_data idata;
+
+	odata.version = HOSTFS_VERSION;
+	get_host_data(hf_Handshake, 0, &odata, &idata);
+
+	if (idata.sys_error || idata.magic != HOSTFS_MAGIC) {
+		printk(DEVICE_NAME
+		       " Handshake with Simics module failed (err=%d, magic=%x/expected %x!\n",
+		       idata.sys_error, idata.magic, HOSTFS_MAGIC);
+		goto out_fail;
+	}
+
+	printk(DEVICE_NAME " mounted\n");
+
+	sb->s_op = &hostfs_super_ops;
+	sb->s_magic = HOSTFS_MAGIC;
+	sb->s_blocksize = HOSTFS_BLOCK_SIZE;
+	sb->s_blocksize_bits = HOSTFS_BLOCK_BITS;
+	root_inode = new_inode(sb);
+	if (!root_inode)
+		goto out_fail;
+	root_inode->i_ino = HOSTFS_ROOT_INO;
+	hostfs_read_inode(root_inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+	sb->s_root = d_make_root(root_inode);
+#else
+	sb->s_root = d_alloc_root(root_inode);
+#endif
+	if (!sb->s_root)
+		goto out_no_root;
+
+	return 0;
+
+out_no_root:
+	printk(DEVICE_NAME " get root inode failed\n");
+	iput(root_inode);
+
+out_fail:
+	return -EINVAL;
+}
+
+static void hostfs_put_super(struct super_block *sb)
+{
+	struct hf_common_data idata;
+	get_host_data(hf_Unmount, 0, NULL, &idata);
+}
+
+static struct super_operations hostfs_super_ops = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+	.read_inode = hostfs_read_inode,
+#endif
+	.write_inode = hostfs_write_inode,
+	.put_super = hostfs_put_super,
+	.statfs = hostfs_statfs,
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
+static struct dentry *hostfs_mount(struct file_system_type *fs_type,
+				   int flags, const char *dev_name, void *data)
+{
+	return mount_nodev(fs_type, flags, data, hostfs_read_super);
+}
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+static int
+hostfs_get_sb(struct file_system_type *fs_type,
+	      int flags, const char *dev_name, void *data, struct vfsmount *mnt)
+{
+	return get_sb_nodev(fs_type, flags, data, hostfs_read_super, mnt);
+}
+#else
+static struct super_block *hostfs_get_sb(struct file_system_type *fs_type,
+					 int flags, const char *dev_name,
+					 void *data)
+{
+	return get_sb_nodev(fs_type, flags, data, hostfs_read_super);
+}
+#endif
+
+static struct file_system_type host_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "simicsfs",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
+	.mount = hostfs_mount,
+#else
+	.get_sb = hostfs_get_sb,
+#endif
+	.kill_sb = kill_anon_super,
+};
+
+static int
+__init init_hostfs(void)
+{
+	printk(DEVICE_NAME " " SYMBOL_TO_STRING(HOSTFS_VERSION) "."
+	       SYMBOL_TO_STRING(HOSTFS_SUBVERSION) " loaded\n");
+	init_host_fs();
+	return register_filesystem(&host_fs_type);
+}
+
+static void
+__exit cleanup_hostfs(void)
+{
+	unregister_filesystem(&host_fs_type);
+	printk(DEVICE_NAME " unloaded\n");
+}
+
+module_init(init_hostfs);
+module_exit(cleanup_hostfs);
diff --git a/meta-simics-qsp/recipes-kernel/simicsfs-mod/simicsfs-mod_1.20.bb b/meta-simics-qsp/recipes-kernel/simicsfs-mod/simicsfs-mod_1.20.bb
new file mode 100644
index 0000000..4c2be33
--- /dev/null
+++ b/meta-simics-qsp/recipes-kernel/simicsfs-mod/simicsfs-mod_1.20.bb
@@ -0,0 +1,34 @@
+SUMMARY = "SimicsFS kernel module that talks to a simulated device"
+DESCRIPTION="SimicsFS gives you access to the file system of your real computer inside the simulated machine. This greatly simplifies the process of importing files into the simulated machine."
+LICENSE = "GPLv2"
+LIC_FILES_CHKSUM = "file://README;md5=d85032171211186dc98a06988cb7504a"
+
+inherit module
+
+PV="1.20"
+
+SRC_URI = "file://CHANGES \
+           file://Kconfig \
+           file://Makefile \
+           file://README \
+           file://README.html \
+           file://hostfs.h \
+           file://hostfs_data.h \
+           file://hostfs_dir.c \
+           file://hostfs_file.c \
+           file://hostfs_host.c \
+           file://hostfs_inode.c \
+           file://hostfs_linux.h \
+           file://hostfs_super.c \
+           "
+
+S = "${WORKDIR}"
+export KERNELDIR="${KERNEL_SRC}"
+
+do_install_append () {
+	mkdir -p ${D}/host
+
+}
+
+FILES_${PN} += "host"
+
diff --git a/meta-yocto-bsp/conf/machine/genericx86-64.conf b/meta-yocto-bsp/conf/machine/genericx86-64.conf
index d843fd2..369385e 100644
--- a/meta-yocto-bsp/conf/machine/genericx86-64.conf
+++ b/meta-yocto-bsp/conf/machine/genericx86-64.conf
@@ -10,3 +10,9 @@ require conf/machine/include/genericx86-common.inc
 PREFERRED_VERSION_linux-yocto_genericx86-64 ?= "4.8%"
 
 SERIAL_CONSOLES_CHECK = "ttyS0"
+
+#jl
+MACHINE_ESSENTIAL_EXTRA_RDEPENDS += "kernel-module-simicsfs"
+KERNEL_MODULE_AUTOLOAD += " simicsfs"
+IMAGE_INSTALL_append = " simicsfs-mod"
+
diff --git a/meta/recipes-core/busybox/busybox.inc b/meta/recipes-core/busybox/busybox.inc
index b2f1960..a431d3e 100644
--- a/meta/recipes-core/busybox/busybox.inc
+++ b/meta/recipes-core/busybox/busybox.inc
@@ -26,10 +26,14 @@ PACKAGES =+ "${PN}-httpd ${PN}-udhcpd ${PN}-udhcpc ${PN}-syslog ${PN}-mdev ${PN}
 FILES_${PN}-httpd = "${sysconfdir}/init.d/busybox-httpd /srv/www"
 FILES_${PN}-syslog = "${sysconfdir}/init.d/syslog* ${sysconfdir}/syslog-startup.conf* ${sysconfdir}/syslog.conf* ${systemd_unitdir}/system/syslog.service ${sysconfdir}/default/busybox-syslog"
 FILES_${PN}-mdev = "${sysconfdir}/init.d/mdev ${sysconfdir}/mdev.conf ${sysconfdir}/mdev/*"
-FILES_${PN}-udhcpd = "${sysconfdir}/init.d/busybox-udhcpd"
+#FILES_${PN}-udhcpd = "${sysconfdir}/init.d/busybox-udhcpd"
 FILES_${PN}-udhcpc = "${sysconfdir}/udhcpc.d ${datadir}/udhcpc"
 FILES_${PN}-hwclock = "${sysconfdir}/init.d/hwclock.sh"
 
+FILES_${PN}  += "/tftpboot/"
+FILES_${PN}  += "${sysconfdir}/init.d/inetd.busybox"
+
+
 INITSCRIPT_PACKAGES = "${PN}-httpd ${PN}-syslog ${PN}-udhcpd ${PN}-mdev ${PN}-hwclock"
 
 INITSCRIPT_NAME_${PN}-httpd = "busybox-httpd"
@@ -183,6 +187,11 @@ do_install () {
 
 	install -d ${D}${sysconfdir}/init.d
 
+#jl Add a tftpboot folder and sample file
+	install -d ${D}${base_prefix}/tftpboot
+	install -m 0644 ${WORKDIR}/testfile.txt    ${D}/tftpboot/testfile.txt 
+
+
 	if ! grep -q "CONFIG_FEATURE_INDIVIDUAL=y" ${B}/.config; then
 		# Install ${base_bindir}/busybox, and the ${base_bindir}/sh link so the postinst script
 		# can run. Let update-alternatives handle the rest.
@@ -251,6 +260,14 @@ do_install () {
 	fi
 	if grep "CONFIG_UDHCPD=y" ${B}/.config; then
 		install -m 0755 ${WORKDIR}/busybox-udhcpd ${D}${sysconfdir}/init.d/
+#jl
+		install -m 0755 ${WORKDIR}/busybox-udhcpd ${D}${sysconfdir}/init.d/busybox-udhcpd
+		install -m 0644 ${WORKDIR}/udhcpd.conf    ${D}${sysconfdir}/udhcpd.conf
+
+	
+		update-rc.d -r ${D} busybox-udhcpd start 85 2 3 4 5 .
+
+
 	fi
 	if grep "CONFIG_HWCLOCK=y" ${B}/.config; then
 		install -m 0755 ${WORKDIR}/hwclock.sh ${D}${sysconfdir}/init.d/
@@ -266,6 +283,11 @@ do_install () {
 		install -m 0755 ${WORKDIR}/inetd ${D}${sysconfdir}/init.d/inetd.${BPN}
 		sed -i "s:/usr/sbin/:${sbindir}/:" ${D}${sysconfdir}/init.d/inetd.${BPN}
 		install -m 0644 ${WORKDIR}/inetd.conf ${D}${sysconfdir}/
+
+#jl
+                update-rc.d -r ${D} inetd.busybox start 80 2 3 4 5 .
+
+
 	fi
         if grep "CONFIG_MDEV=y" ${B}/.config; then
                install -m 0755 ${WORKDIR}/mdev ${D}${sysconfdir}/init.d/mdev
diff --git a/meta/recipes-core/busybox/busybox/defconfig b/meta/recipes-core/busybox/busybox/defconfig
index c0459d5..288a7ad 100644
--- a/meta/recipes-core/busybox/busybox/defconfig
+++ b/meta/recipes-core/busybox/busybox/defconfig
@@ -775,9 +775,9 @@ CONFIG_FEATURE_WGET_STATUSBAR=y
 CONFIG_FEATURE_WGET_AUTHENTICATION=y
 CONFIG_FEATURE_WGET_LONG_OPTIONS=y
 CONFIG_FEATURE_WGET_TIMEOUT=y
-# CONFIG_FEATURE_WGET_OPENSSL is not set
-# CONFIG_FEATURE_WGET_SSL_HELPER is not set
-# CONFIG_WHOIS is not set
+CONFIG_FEATURE_WGET_OPENSSL=y
+CONFIG_FEATURE_WGET_SSL_HELPER=y
+CONFIG_WHOIS=y
 CONFIG_FEATURE_IPV6=y
 # CONFIG_FEATURE_UNIX_LOCAL is not set
 CONFIG_FEATURE_PREFER_IPV4_ADDRESS=y
@@ -790,12 +790,12 @@ CONFIG_FEATURE_PREFER_IPV4_ADDRESS=y
 # CONFIG_DNSD is not set
 # CONFIG_ETHER_WAKE is not set
 # CONFIG_FAKEIDENTD is not set
-# CONFIG_FTPD is not set
+CONFIG_FTPD=y
 # CONFIG_FEATURE_FTP_WRITE is not set
 # CONFIG_FEATURE_FTPD_ACCEPT_BROKEN_LIST is not set
 # CONFIG_FEATURE_FTP_AUTHENTICATION is not set
-# CONFIG_FTPGET is not set
-# CONFIG_FTPPUT is not set
+CONFIG_FTPGET=y
+CONFIG_FTPPUT=y
 # CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS is not set
 CONFIG_HOSTNAME=y
 # CONFIG_HTTPD is not set
@@ -827,13 +827,13 @@ CONFIG_FEATURE_IFUPDOWN_IPV4=y
 CONFIG_FEATURE_IFUPDOWN_IPV6=y
 CONFIG_FEATURE_IFUPDOWN_MAPPING=y
 CONFIG_FEATURE_IFUPDOWN_EXTERNAL_DHCP=y
-# CONFIG_INETD is not set
-# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO is not set
-# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD is not set
-# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME is not set
-# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME is not set
-# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN is not set
-# CONFIG_FEATURE_INETD_RPC is not set
+CONFIG_INETD=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME=y
+CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN=y
+CONFIG_FEATURE_INETD_RPC=y
 CONFIG_IP=y
 CONFIG_FEATURE_IP_ADDRESS=y
 CONFIG_FEATURE_IP_LINK=y
@@ -865,20 +865,20 @@ CONFIG_ROUTE=y
 CONFIG_TELNET=y
 # CONFIG_FEATURE_TELNET_TTYPE is not set
 CONFIG_FEATURE_TELNET_AUTOLOGIN=y
-# CONFIG_TELNETD is not set
-# CONFIG_FEATURE_TELNETD_STANDALONE is not set
-# CONFIG_FEATURE_TELNETD_INETD_WAIT is not set
+CONFIG_TELNETD=y
+CONFIG_FEATURE_TELNETD_STANDALONE=y
+CONFIG_FEATURE_TELNETD_INETD_WAIT=y
 CONFIG_TFTP=y
-# CONFIG_TFTPD is not set
+CONFIG_TFTPD=y
 
 #
 # Common options for tftp/tftpd
 #
 CONFIG_FEATURE_TFTP_GET=y
 CONFIG_FEATURE_TFTP_PUT=y
-# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
-# CONFIG_FEATURE_TFTP_PROGRESS_BAR is not set
-# CONFIG_TFTP_DEBUG is not set
+CONFIG_FEATURE_TFTP_BLOCKSIZE=y
+CONFIG_FEATURE_TFTP_PROGRESS_BAR=y
+#CONFIG_TFTP_DEBUG is not set
 CONFIG_TRACEROUTE=y
 # CONFIG_TRACEROUTE6 is not set
 # CONFIG_FEATURE_TRACEROUTE_VERBOSE is not set
diff --git a/meta/recipes-core/busybox/busybox_1.24.1.bb b/meta/recipes-core/busybox/busybox_1.24.1.bb
index 400cdfe..c177680 100644
--- a/meta/recipes-core/busybox/busybox_1.24.1.bb
+++ b/meta/recipes-core/busybox/busybox_1.24.1.bb
@@ -57,6 +57,8 @@ SRC_URI = "http://www.busybox.net/downloads/busybox-${PV}.tar.bz2;name=tarball \
            file://0001-libiproute-handle-table-ids-larger-than-255.patch \
            file://ifupdown-pass-interface-device-name-for-ipv6-route-c.patch \
            file://BUG9071_buffer_overflow_arp.patch \
+           file://udhcpd.conf  \
+	   file://testfile.txt \
 "
 SRC_URI_append_libc-musl = " file://musl.cfg "
 
diff --git a/meta/recipes-core/busybox/busybox_git.bb b/meta/recipes-core/busybox/busybox_git.bb
index c29b894..082cb95 100644
--- a/meta/recipes-core/busybox/busybox_git.bb
+++ b/meta/recipes-core/busybox/busybox_git.bb
@@ -46,6 +46,8 @@ SRC_URI = "git://busybox.net/busybox.git \
            file://rcS \
            file://rcK \
            file://runlevel \
+           file://udhcpd.conf  \
+	   file://testfile.txt \
 "
 SRC_URI_append_libc-musl = " file://musl.cfg "
 
diff --git a/meta/recipes-core/busybox/files/inetd.conf b/meta/recipes-core/busybox/files/inetd.conf
index b02fe85..b94b9e5 100644
--- a/meta/recipes-core/busybox/files/inetd.conf
+++ b/meta/recipes-core/busybox/files/inetd.conf
@@ -18,3 +18,6 @@
 #daytime	dgram	udp	wait	root	internal
 #time		stream	tcp	nowait	root	internal
 #time		dgram	udp	wait	root	internal
+69              dgram   udp     nowait  root    tftpd   tftpd -c /tftpboot
+23              stream  tcp     nowait  root    /usr/sbin/telnetd      telnetd -i -l /bin/login
+ 
diff --git a/meta/recipes-core/busybox/files/testfile.txt b/meta/recipes-core/busybox/files/testfile.txt
new file mode 100644
index 0000000..2422dda
--- /dev/null
+++ b/meta/recipes-core/busybox/files/testfile.txt
@@ -0,0 +1,54 @@
+duDGan9rQHO6XFMKy/gpkwKW03rfVh2F2RYjsd8aO8ZaYqyir41+MjK37rdFKkb4X9u3sQJibXyL
+o/6UKPiKte7/aoUmz7BOjT7qX09YcAbLs/5JqjnLgBY0Ed8+GJmaZeMCrRDbsYnVi0dbnHaIREkl
+FNIztEf7NbV9Y7wD05Lr2XfQ9VSchaM294AS0Se7JA3gtfqjYovpD0ME9VDqeTsIIKKc+nPchJzh
+pqTXDwqLf0K2mD5AdkFgMZgTD8GAWJ3d8mYW2Msx38ooqc7IRJD7x2oq58iyI2rs3vjj/fp4oIYS
+yOMZu3der89kuieFwSVZiTihJBE6J31F6fWr2exLfsxSmqbdTA8oOuvjmio9+I6JQRw59RL4zgTn
+XFtJjTwUpNx8DXonWLPdTN0WhCKp/JeGsXshzp0EAqNCNHZV+oEiLldq/68G4QhYiK9P2gHmwLXI
+1EAA5QEyU9E89LwN/BAZQfXvLbrdBGd1YXgRHHjqJ51JtJp5DyKPhQz5JzRcSZWU5d0pQcEJN6+1
+ZxP+w5fZnsmz4CAvRvyutFzofBV1tKG4+LVeHy9ryQnW8AjeBxZ+pupbpRSb6qe4nNaNfCjKphHN
+eWG1X7zzRI5BHPu+NzheOO4vSkBH+udG0dEC1pgdIMVseo/EGg0fECkkq0jLm91AbcCfj1o14m/y
+6irOwURWgrA6cA2EuYHOpuxBPxYlsWQP8/mt9XH+ZkNs8juACL3srLa83Nv422FyPYX21mNBPmMm
+uKuKAZQmPiwwbz31hEnVsSgoxIJQqR93bgPnlQ2ztobKKcnTb+c1UENLc/RfxRS0JvUj9vnhW9eM
+4Lhcu82b9gKjm04np70jk4q9ZA5GxvlLl3/CPd4hiCIux/tZ2KpopHDuS9lhdCsUtpXND3XmUJjB
+eS5bEKvjALnth1LEWSMihRdOy9pJXUV4PKLzEcQI+AU0iQfTXSEnJm9+Ucs2zOXMENmaOwkC8jJw
+NYEAj19ArbCM/3kImmc45MWSXGaS6+MWec0DHfXreTqTWQ8MGnRHeJPkSAd6roPGuI9XAzcjAo93
+kLXrXv5AymxgzBf66qA1tl6chAVas9v2sNe8U+t1oWubI44qLJofLd05X63PVwBpeESiD8H0FFAw
+bTgtb9DREiIiiI7MdZbb1/1WrhKxPxMaXuvURWwBCKbR/FRBC/Rv4uvNqaBcjkcpiPp6BRYWhKGP
+VE4FwAG0gUNBV0LJS1UaJCM9klM1jVlE4W3VZov9BLuUl9WXOArhTDYNZfeazxAaK5rZHN1uzZQ6
+CjEVqCTjPiKulIG9IMqYGXd5LmiHIQ8Cdlo7DnrhjaV3a5ma1R3ZhwJRzwR1ksHzVUxOnvoBX1kv
+v6Z7FKNKibGiYmbE02+vyCQmtxkGqMNRMqe3Fkzg5cEyX7x+M6Znmlbmv6A0IMGMRt0FBjJDC9uY
+Dcot/XHaoqjER10aFKXcV0exc8Jpde8CxImf9E0QgTziFWxliKfGRYke66cAJBjQuSaWL6lXOwh0
+E+Gca/U0NcyUy1yWBiAgyWmQwubnajPO6dX1DGEIhCKMdNoOIoh69QBsr/QEilfXbPUsFIFYpiwQ
+nVfx2SssK/ZWpeHXPbdba+HlDCeYbWZmO6oCYihfUkTwdkgTMIu3cQa0X5LCkZkcnrf8RhDEjsw3
+0nsRe2KhaMzq4blql2wX5PrXZVQElin31woYI3VCk87QL466gj8O56xPP8tYcUZ+UAoDNbc7vzg4
+MpehUqdPgOqjOa8dJjzEA+w8AOKhoEhur4oBWcreun3RN1PmIVPvB6Sv7e3guTJciwGF/8VCGTEN
+s2dJBUrQBDPIY8erl88y90/kfCHWTtUGQd4IJPl+u1r1K7y8WpAT6+bS0GZdOGZS1Lp93+xFIBRq
+/LkdlXMHRiElc3RBPM4kzbYqQ8dAD9dD0y5PNW62YHjlr2w5M1vVZaFt313bULmxDIuTw4YJKzHf
+hL3LEKLBykBDPr/FrHznDDcUgbenNtAgSfspZq+/TVyriOEk5RjCfl9tFJB9iATgXBVM8GxCONyX
+BFhiV6DQc0k7BxVh/C5kNHF/8iQnur8klNZdQJyNUgvKu2knUuO/pl5oHKJLXrto4eNwp0+9n/I0
+4EGxSXodFj/1ueEUxHKQs4eMHDZVVIDiJfzMYyl2zoUAS5GR8iH/co1lR8MvVrqbVuZZs938YO7k
+fGVVasrAxiRh+EqdNon+Tk0rDvvY1JPm6R8Eea1KRDKgmfW45Sdxr9BQjd8BaghZpM0YOCrSmqAN
+T3JPQjooEULakV4m9hxzB8ijQUXXBJaUjkcGFrK61vZYoSrA/zevLgk0SxXUqeQr2uV92uMY/UH5
+21VY7/Zkcec0RPTAgPdPcnXDuuZT2mwyaECtllwypTlFBveG21MJEO0LEKHKiV9dlLKgJtiatwVc
+9w7KpGONXJUq5yTBN9ssHPbxzH0wu0RvyjPm7aPyuLNGZOU1JvAfgtutGYWf2cFzq11fGuQQQf0+
+F3fmG9M9JEuVwVefpVZ45UjPeAWS6FBa7kICNnP32aU7i9rCXqfYB9kpLA7ykQN3c7nLT7R0H7YY
+ZFdPFfSU8TccJZuBOGS4ctBPb6hg5s69Y974G9dq+2pbwTHhoCcUODaZj4LQRHLqtxwD6wRWQEIR
+kzT8VOcamVywJyLMzmOarSL/0bHpbwDBulfJ6gi8zNmQVjzsnGN5Qhr1fH60UyZKucTomPlYaQak
+AicPPFhuo9bbvmuH4LRshR+/l7YGkdYgiwgm2FJ399y+a/UesBiox47qodbzHGBHsc/L9RUxlH87
+5azrQswC13hZXv6O27T7KMAmZtuh6WMT3bLwb/EsOeWmAnUQ3o7dlrYcSqkgBTKE1D1cp8t2wmDj
+WdlIls1by+bakYH1E9cofdOncCxBt0aBWzAc11TGVZ2yw2Sb9t06geY377RfutDa7XYvI4obZWJu
+LF1l3QWDdJ+YF0qqV6hc7agmibQuutdka8moUvv2KRWfxlLOy2R8PFai+We7QY9jDJQyF5+QtKHY
+OWlreZSsMftJXLLWqoRYhvt9JOkEMMRGpcZiCXxbwNW4kMMlyp8lmd1Dawm/m2xcxMDOByyn1h6F
+OAZjj/8NLllHTlG2+GE4a0qtjkawbmHqRD9/8OqvDWercYcxV/FFv8wQupDwnKEI0EBlvStXDUDz
+hK7EljfWMPGBGV8YmR6c9LkvfoS0SGWxRiRFeKbKGfXMWxzmYbnGb8hIewfR9GDj5Hn5R+C5iJWX
+HzvG0uhtB/9u3Q/F7zNvJ2MMuYjGIqB0T0arPbiJvlqekCqyGHCt/im8fLvxiXG2A/CTYY6u9PkW
+SYF66vL/WtE3vQgxLa6D/m4F1RfLqlCE/mcY3u/Sq+puSxYgJzPDu2QxUqiedH/cJLIKXdf6Qtna
+mWQVujRgxcFnuNKiqOvrvHxwrBRgwLLPqJjmpDyiw+sg3vxbe8uh1tLfbATWJ31mEsDIqnjTwtRR
+cwIlTQ9Ioub2DFKYt8IIDnoXBdoGACS5029FJ86h09qsnAxRmmeAJ9xuxPNXokX59udju45/l6VH
+wrQBuAuOy9DJHjHdo+Y1jiLjBbYCygEa/Z8mqvb6blvyZQkJa7vQ+/K1Z5nbMxNnZ52szGdtnAx8
+twx4rUmOJ6obpjAA51DfM9Pyl/+Sik5qQ4ctbpkKf+HU8BBXpgoqSz6KCawI0DKO/mdjIqHZU8YE
+4P6TGGrixnBRTQXZsnzIMFLw0/fhuaKzXE+Gzh+xHsmtL/xMs0ayJ92yDFoIStqdZNIkh5Ulxb8N
+ObxLYOtxQ4rEkb/EHFKx6N0AddnKV/ThnJkFSTDoGMF+D1ABIurOKUvKtF01dTgYttumilEQnE/I
+wVaSB3rH+e3zYQjNp5fIkTOqWga1fEB6Mn+5R5CyPVUYkPie7gEIIGJOmdrBbpFEgSqN6aeqIp/S
+Vo5ZxQfsCiRC9AFXghibw/c4Vp7n7pj4U7Qz7CL2i6PsIICsD2cgHp6aJvUs6Efqvji9C4MSJ2+j
+NGrqJUQXRPCdbRC
\ No newline at end of file
diff --git a/meta/recipes-core/busybox/files/udhcpd.conf b/meta/recipes-core/busybox/files/udhcpd.conf
new file mode 100644
index 0000000..63cbacf
--- /dev/null
+++ b/meta/recipes-core/busybox/files/udhcpd.conf
@@ -0,0 +1,113 @@
+# Sample udhcpd configuration file (/etc/udhcpd.conf)
+# Values shown are defaults
+
+# The start and end of the IP lease block
+start		10.10.0.20
+end		10.10.0.254
+
+# The interface that udhcpd will use
+interface	eth0
+
+# The maximum number of leases (includes addresses reserved
+# by OFFER's, DECLINE's, and ARP conflicts). Will be corrected
+# if it's bigger than IP lease block, but it ok to make it
+# smaller than lease block.
+#max_leases	254
+
+# The amount of time that an IP will be reserved (leased to nobody)
+# if a DHCP decline message is received (seconds)
+#decline_time	3600
+
+# The amount of time that an IP will be reserved
+# if an ARP conflict occurs (seconds)
+#conflict_time	3600
+
+# How long an offered address is reserved (seconds)
+#offer_time	60
+
+# If client asks for lease below this value, it will be rounded up
+# to this value (seconds)
+#min_lease	60
+
+# The location of the pid file
+#pidfile	/var/run/udhcpd.pid
+
+# The location of the leases file
+#lease_file	/var/lib/misc/udhcpd.leases
+
+# The time period at which udhcpd will write out leases file.
+# If this is 0, udhcpd will never automatically write leases file.
+# Specified in seconds.
+#auto_time	7200
+
+# Every time udhcpd writes a leases file, the below script will be called
+#notify_file			# default: no script
+#notify_file	dumpleases	# useful for debugging
+
+# The following are bootp specific options
+# next server to use in bootstrap
+#siaddr		192.168.0.22	# default: 0.0.0.0 (none)
+# tftp server name
+#sname		zorak		# default: none
+# tftp file to download (e.g. kernel image)
+#boot_file	/var/nfs_root	# default: none
+
+# Static leases map
+#static_lease 00:60:08:11:CE:4E 192.168.0.54
+#static_lease 00:60:08:11:CE:3E 192.168.0.44
+
+# The remainder of options are DHCP options and can be specified with the
+# keyword 'opt' or 'option'. If an option can take multiple items, such
+# as the dns option, they can be listed on the same line, or multiple
+# lines.
+# Examples:
+opt	dns	10.10.10.2 10.10.10.10
+option	subnet	255.255.255.0
+opt	router	192.168.10.2
+opt	wins	192.168.10.10
+option	dns	129.219.13.81	# appended to above DNS servers for a total of 3
+option	domain	local
+option	lease	864000		# default: 10 days
+# Arbitrary option in hex form:
+option	0x08	01020304	# option 8: "cookie server IP addr: 1.2.3.4"
+
+# Currently supported options (for more info, see options.c):
+#opt lease      NUM
+#opt subnet     IP
+#opt broadcast  IP
+#opt router     IP_LIST
+#opt ipttl      NUM
+#opt mtu        NUM
+#opt hostname   STRING		# client's hostname
+#opt domain     STRING		# client's domain suffix
+#opt search     STRING_LIST	# search domains
+#opt nisdomain  STRING
+#opt timezone   NUM		# (localtime - UTC_time) in seconds. signed
+#opt tftp       STRING		# tftp server name
+#opt bootfile   STRING		# tftp file to download (e.g. kernel image)
+#opt bootsize   NUM		# size of that file
+#opt rootpath   STRING		# (NFS) path to mount as root fs
+#opt wpad       STRING
+#opt serverid   IP		# default: server's IP
+#opt message    STRING		# error message (udhcpd sends it on success too)
+#opt vlanid     NUM		# 802.1P VLAN ID
+#opt vlanpriority NUM		# 802.1Q VLAN priority
+# Options specifying server(s)
+#opt dns        IP_LIST
+#opt wins       IP_LIST
+#opt nissrv     IP_LIST
+#opt ntpsrv     IP_LIST
+#opt lprsrv     IP_LIST
+#opt swapsrv    IP
+# Options specifying routes
+#opt routes     IP_PAIR_LIST
+# Obsolete options, no longer supported
+#opt logsrv     IP_LIST	# 704/UDP log server (not syslog!)
+#opt namesrv    IP_LIST	# IEN 116 name server, obsolete (August 1979!!!)
+#opt cookiesrv  IP_LIST	# RFC 865 "quote of the day" server, rarely (never?) used
+#opt timesrv    IP_LIST	# RFC 868 time server, rarely (never?) used
+# TODO: in development
+#opt userclass  STRING		# RFC 3004. set of LASCII strings. "I am a printer" etc
+#opt sipserv    STRING LIST	# RFC 3361. flag byte, then: 0: domain names, 1: IP addrs
+#opt staticroutes   STATIC_ROUTES
+#opt msstaticroutes STATIC_ROUTES
diff --git a/meta/recipes-core/init-ifupdown/init-ifupdown-1.0/interfaces b/meta/recipes-core/init-ifupdown/init-ifupdown-1.0/interfaces
index 0acf4cf..c68b056 100644
--- a/meta/recipes-core/init-ifupdown/init-ifupdown-1.0/interfaces
+++ b/meta/recipes-core/init-ifupdown/init-ifupdown-1.0/interfaces
@@ -15,9 +15,18 @@ iface atml0 inet dhcp
 
 # Wired or wireless interfaces
 auto eth0
-iface eth0 inet dhcp
+iface eth0 inet static
+	address 10.10.0.10
+	netmask 255.255.255.0
+	network 10.10.0.0
+	gateway 10.10.0.1
+
+#iface eth0 inet dhcp
+
 iface eth1 inet dhcp
 
+
+
 # Ethernet/RNDIS gadget (g_ether)
 # ... or on host side, usbnet and random hwaddr
 iface usb0 inet static
diff --git a/scripts/lib/wic/canned-wks/directdisk_qsp.wks b/scripts/lib/wic/canned-wks/directdisk_qsp.wks
new file mode 100644
index 0000000..4b36b3d
--- /dev/null
+++ b/scripts/lib/wic/canned-wks/directdisk_qsp.wks
@@ -0,0 +1,13 @@
+# short-description: Create a 'pcbios' direct disk image
+# long-description: Creates a partitioned legacy BIOS disk image that the user
+# can directly dd to boot media.
+
+# Simics changes:
+# - add '--size 2000'
+# - vga=0x318 changed to vga=0x202
+
+part /boot --source bootimg-pcbios --ondisk sda --label boot --active --align 1024
+part / --source rootfs --ondisk sda --fstype=ext3 --label platform --align 1024 --size 2000
+
+bootloader  --timeout=0  --append="rootwait rootfstype=ext3  console=ttyS0"
+
